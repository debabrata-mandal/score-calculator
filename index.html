<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>‚≠ê Rummy Score Master</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      margin: 0;
    }

    .container {
      max-width: 1000px;
      margin: auto;
    }

    /* Dynamic header sizing */
    h1 {
      white-space: nowrap;
      overflow: hidden;
      font-size: clamp(1.2rem, 4vw, 2rem);
      margin: 0 0 20px 0;
      background: linear-gradient(135deg, #007bff, #28a745);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
    }

    /* Section headers */
    h2 {
      color: #495057;
      font-weight: 600;
      margin-bottom: 15px;
      border-bottom: 2px solid #e9ecef;
      padding-bottom: 5px;
    }

    /* Table headers with better colors */
    table th {
      background-color: #f8f9fa !important;
      color: #495057 !important;
      font-weight: 600;
    }

    /* Table container for horizontal scroll */
    .table-container {
      overflow-x: auto;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    table {
      border-collapse: collapse;
      margin-top: 0;
      /* Changed from 10px to 0 */
      width: 100%;
      min-width: 800px;
    }

    /* First column (Player Name) - frozen */
    table th:first-child,
    table td:first-child {
      position: sticky;
      left: 0;
      background-color: #fff;
      z-index: 10;
      min-width: 150px;
      max-width: 150px;
      width: 150px;
    }

    table th:first-child {
      background-color: #f8f9fa;
      z-index: 11;
    }

    th,
    td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
      min-width: 60px;
    }

    /* Bigger inputs for better user experience */
    input[type="number"] {
      width: 60px;
      padding: 6px;
      font-size: 14px;
      text-align: center;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    input[type="text"] {
      width: 100%;
      min-width: 120px;
      padding: 6px;
      font-size: 14px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    /* Input fields in tables - transparent styling */
    table input[type="number"],
    table input[type="text"] {
      border: none;
      background: transparent;
      width: 100%;
      padding: 4px;
      font-size: 14px;
    }

    table input[type="number"] {
      text-align: center;
    }

    .leaderboard,
    .chart-container {
      margin-top: 30px;
    }

    .controls {
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      justify-content: flex-start;
      /* Align items to the left */
    }

    button {
      padding: 8px 16px;
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background-color: #c82333;
    }

    /* Special styling for the Start Play button */
    .start-play-button {
      padding: 12px 24px !important;
      font-size: 16px !important;
      font-weight: bold !important;
      background-color: #007bff !important;
      box-shadow: 0 4px 8px rgba(0, 123, 255, 0.3) !important;
      transition: all 0.3s ease !important;
    }

    .start-play-button:hover {
      background-color: #0056b3 !important;
      transform: translateY(-2px) !important;
      box-shadow: 0 6px 12px rgba(0, 123, 255, 0.4) !important;
    }

    canvas {
      max-width: 100%;
      height: auto;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: clamp(1rem, 5vw, 1.5rem);
      }

      /* First column smaller on mobile */
      table th:first-child,
      table td:first-child {
        min-width: 120px;
        max-width: 120px;
        width: 120px;
      }

      input[type="text"] {
        width: 100%;
        min-width: 100px;
        font-size: 13px;
        padding: 4px;
      }

      input[type="number"] {
        width: 55px;
        font-size: 12px;
        padding: 4px;
      }

      th,
      td {
        padding: 4px;
        font-size: 11px;
        min-width: 50px;
      }

      table input[type="number"],
      table input[type="text"] {
        font-size: 12px;
        padding: 2px;
      }

      table input[type="number"] {
        min-width: 45px;
        width: 100%;
      }

      .controls {
        flex-direction: row;
        /* Keep row direction instead of column */
        flex-wrap: wrap;
        align-items: center;
        gap: 5px;
      }

      .controls label {
        width: auto;
        /* Changed from 100% to auto */
        margin-bottom: 0;
        /* Changed from 5px to 0 */
        white-space: nowrap;
        /* Prevent label from wrapping */
      }

      .controls input[type="number"] {
        width: 70px !important;
        font-size: 13px;
      }

      button {
        font-size: 12px;
        padding: 6px 12px;
      }

      .start-play-button {
        padding: 10px 20px !important;
        font-size: 15px !important;
      }
    }

    /* Custom Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 15% auto;
      padding: 20px;
      border: none;
      border-radius: 8px;
      width: 90%;
      max-width: 400px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .modal-buttons {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .modal-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .modal-button.confirm {
      background-color: #dc3545;
      color: white;
    }

    .modal-button.cancel {
      background-color: #6c757d;
      color: white;
    }

    .modal-button:hover {
      opacity: 0.9;
    }

    .leaderboard-table,
    .leaderboard-table * {
      position: static !important;
      left: auto !important;
      z-index: auto !important;
      background-color: transparent !important;
    }

    .leaderboard-table th:first-child,
    .leaderboard-table td:first-child {
      position: static !important;
      left: auto !important;
      background-color: transparent !important;
      z-index: auto !important;
      width: auto !important;
      min-width: auto !important;
      max-width: auto !important;
    }

    .leaderboard-table th:first-child {
      background-color: #f8f9fa !important;
    }

    /* Color improvements */
    /* Header with gradient */
    h1 {
      white-space: nowrap;
      overflow: hidden;
      font-size: clamp(1.2rem, 4vw, 2rem);
      margin: 0 0 20px 0;
      background: linear-gradient(135deg, #007bff, #28a745);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
    }

    /* Section headers */
    h2 {
      color: #495057;
      font-weight: 600;
      margin-bottom: 15px;
      border-bottom: 2px solid #e9ecef;
      padding-bottom: 5px;
    }

    /* Table headers with better colors */
    table th {
      background-color: #f8f9fa !important;
      color: #495057 !important;
      font-weight: 600;
    }

    /* Player name inputs with subtle styling */
    table input[type="text"] {
      border: none;
      background: transparent;
      width: 100%;
      padding: 4px;
      font-size: 14px;
      color: #212529;
      font-weight: 500;
    }

    /* Score inputs with color coding */
    table input[type="number"] {
      border: none;
      background: transparent;
      width: 100%;
      padding: 4px;
      font-size: 14px;
      text-align: center;
      color: #495057;
      font-weight: 500;
    }

    /* Color code score inputs based on value */
    table input[type="number"][value="-1"] {
      color: #6c757d;
      /* Gray for -1 values */
      font-style: italic;
    }

    /* Leaderboard with better colors */
    .leaderboard-table th {
      background-color: #343a40 !important;
      color: white !important;
    }

    .leaderboard-table td:first-child {
      font-weight: bold;
      color: #495057;
      /* Standard color for all ranks */
    }

    /* Player names in leaderboard */
    .leaderboard-table td:nth-child(2) {
      color: #495057;
      font-weight: 500;
    }

    /* Scores in leaderboard with conditional colors */
    .leaderboard-table td:last-child {
      font-weight: 600;
    }

    /* Controls styling */
    .controls label {
      color: #495057;
      font-weight: 500;
    }

    .controls input[type="number"] {
      border: 2px solid #e9ecef;
      color: #495057;
      font-weight: 500;
      border-radius: 4px;
      padding: 6px 8px;
    }

    .controls input[type="number"]:focus {
      border-color: #007bff;
      outline: none;
      box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }

    /* Add Player button with better styling */
    .add-player-btn {
      background: linear-gradient(135deg, #28a745, #20c997) !important;
      border: none;
      color: white;
      font-weight: 600;
      transition: all 0.3s ease;
    }

    .add-player-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
    }

    /* Add these styles to your existing CSS */

    /* Game ID Display styling */
    #gameIdDisplay {
      animation: slideIn 0.5s ease-out;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #gameIdInput {
      user-select: all;
      /* Allow easy text selection */
    }

    #gameIdInput:hover {
      background-color: #f8f9fa !important;
      border-color: #0d47a1 !important;
    }

    #qrCodeContainer:hover {
      background-color: #f0f8ff !important;
      border-color: #0d47a1 !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(13, 71, 161, 0.3);
    }

    #qrCodeContainer.copied {
      background-color: #e8f5e8 !important;
      border-color: #4caf50 !important;
      animation: pulse 0.6s ease-in-out;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    /* QR Scanner specific animations */
    @keyframes scannerPulse {
      0% {
        border-color: #00ff00;
        background: rgba(0, 255, 0, 0.1);
      }

      50% {
        border-color: #00aa00;
        background: rgba(0, 255, 0, 0.2);
      }

      100% {
        border-color: #00ff00;
        background: rgba(0, 255, 0, 0.1);
      }
    }

    /* Mobile responsive for Game ID display */
    @media (max-width: 768px) {
      #gameIdDisplay {
        margin: 10px 0;
        padding: 10px;
      }

      #gameIdInput {
        font-size: 16px;
        min-width: 100px;
      }
    }

    /* Update controls styling for better button alignment */
    .controls {
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
      justify-content: flex-start;
      /* Align items to the left */
    }

    /* Make Start Play button same size as Load Game button when inline */
    .controls .start-play-button {
      padding: 8px 16px !important;
      font-size: 14px !important;
      font-weight: bold !important;
      background-color: #007bff !important;
      box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3) !important;
      transition: all 0.3s ease !important;
      margin: 0 !important;
      /* Remove any margin */
    }

    .controls .start-play-button:hover {
      background-color: #0056b3 !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 8px rgba(0, 123, 255, 0.4) !important;
    }

    /* Ensure buttons are same height */
    .controls button {
      padding: 8px 16px;
      background-color: #dc3545;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      height: auto;
      /* Let height be determined by padding */
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* Mobile responsive adjustments */
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .controls>div {
        display: flex;
        align-items: center;
        gap: 5px;
        justify-content: space-between;
      }

      /* Stack buttons on mobile */
      .controls button {
        width: 100%;
        margin-bottom: 5px;
      }

      .controls .start-play-button {
        width: 100% !important;
        padding: 10px 16px !important;
        font-size: 14px !important;
      }
    }

    /* Alternative mobile-friendly layout */
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
        gap: 8px;
      }

      .controls>div {
        display: flex;
        align-items: center;
        gap: 5px;
        justify-content: space-between;
        width: 100%;
      }

      /* Financial inputs group */
      .controls div:nth-child(1) {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
        width: 100%;
      }

      /* Action buttons group */
      .controls div:nth-child(2) {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        width: 100%;
      }
    }

    /* Disabled button styling */
    button:disabled {
      background-color: #6c757d !important;
      opacity: 0.6 !important;
      cursor: not-allowed !important;
      pointer-events: none;
    }

    button:disabled:hover {
      background-color: #6c757d !important;
      transform: none !important;
      box-shadow: none !important;
    }

    @keyframes slideInRight {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOutRight {
      from {
        transform: translateX(0);
        opacity: 1;
      }

      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    /* Mobile responsive for toast */
    @media (max-width: 768px) {
      #toast {
        top: 10px !important;
        right: 10px !important;
        left: 10px !important;
        max-width: none !important;
        font-size: 13px !important;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>‚≠ê Rummy Score Master</h1>

    <!-- Move Game ID Display Section here - right after title -->
    <!-- Update the Game ID Display Section to be cleaner -->
    <div id="gameIdDisplay" style="
          text-align: center;
          margin: 15px 0;
          padding: 12px;
          background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
          border-radius: 8px;
          border: 2px solid #e1bee7;
          display: none;
        ">
      <div style="
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
          ">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 6px;">
          <div id="qrCodeContainer" style="
                background: white;
                border: 2px solid #1565c0;
                border-radius: 6px;
                padding: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                min-width: 120px;
                min-height: 50px;
                cursor: pointer;
                transition: all 0.3s ease;
              " onclick="copyGameId()" title="Click to copy Game ID"></div>
          <div id="gameIdPinText" style="font-size: 15px; color: #333; margin-top: 2px;"></div>
        </div>
      </div>
      <!-- QRCode.js CDN -->
      <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    </div>

    <!-- QR Scanner Modal -->
    <div id="qrScannerModal" class="modal">
      <div class="modal-content" style="max-width: 500px; padding: 15px;">
        <h3 style="margin: 0 0 15px 0; text-align: center;">üì± Scan QR Code</h3>
        
        <!-- Mode Selection Radio Buttons -->
        <div style="
          display: flex;
          justify-content: center;
          gap: 20px;
          margin: 15px 0;
          padding: 10px;
          background: linear-gradient(135deg, #f8f9fa, #e9ecef);
          border-radius: 8px;
          border: 1px solid #dee2e6;
        ">
          <label style="
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
          ">
            <input type="radio" name="scanMode" value="view" checked style="
              margin: 0;
              transform: scale(1.1);
            ">
            <span>üëÅÔ∏è View Only</span>
          </label>
          <label style="
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
          ">
            <input type="radio" name="scanMode" value="edit" style="
              margin: 0;
              transform: scale(1.1);
            ">
            <span>‚úèÔ∏è Edit Mode</span>
          </label>
        </div>
        
        <!-- PIN Input Container (initially hidden) -->
        <div id="pinContainer" style="
          display: none;
          margin: 15px 0;
          padding: 15px;
          background: linear-gradient(135deg, #fff3cd, #ffeaa7);
          border: 2px solid #ffc107;
          border-radius: 8px;
          text-align: center;
        ">
          <label for="pinInput" style="
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #856404;
            font-size: 14px;
          ">
            üîê Enter PIN for Edit Access:
          </label>
          <input type="password" id="pinInput" maxlength="4" placeholder="4-digit PIN" style="
            width: 120px;
            padding: 10px 8px;
            text-align: center;
            border: 2px solid #ffc107;
            border-radius: 6px;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 3px;
            background-color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
          ">
          <div id="pinMessage" style="
            margin-top: 10px;
            font-size: 13px;
            font-weight: 500;
            min-height: 18px;
            transition: all 0.3s ease;
          "></div>
        </div>
        
        <div id="qrScannerContainer" style="
          position: relative;
          width: 100%;
          max-width: 400px;
          margin: 0 auto;
          background: #000;
          border-radius: 8px;
          overflow: hidden;
        ">
          <video id="qrScannerVideo" style="
            width: 100%;
            height: 300px;
            object-fit: cover;
            display: block;
          "></video>
          <div id="scannerOverlay" style="
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
          ">
            <div id="scannerFrame" style="
              width: 250px;
              height: 250px;
              border: 3px solid #00ff00;
              border-radius: 12px;
              background: rgba(0, 255, 0, 0.1);
              animation: scannerPulse 2s infinite;
              position: relative;
              display: flex;
              align-items: center;
              justify-content: center;
            ">
              <div style="
                color: #00ff00;
                font-size: 16px;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                text-align: center;
                padding: 10px;
              ">
                üì± Position QR Code Here
              </div>
            </div>
          </div>
          <canvas id="qrScannerCanvas" style="display: none;"></canvas>
        </div>
        <div style="margin-top: 15px; text-align: center;">
          <p id="scannerStatus" style="color: #007bff; font-size: 14px; margin: 10px 0; font-weight: 500;">
            üì∑ Starting camera...
          </p>
          <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
            <button id="switchCameraBtn" onclick="switchCamera()" style="
              background-color: #17a2b8;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 8px 16px;
              cursor: pointer;
              font-size: 14px;
              display: none;
            ">üîÑ Switch Camera</button>
            <button onclick="manualEntry()" style="
              background-color: #ffc107;
              color: #212529;
              border: none;
              border-radius: 4px;
              padding: 8px 16px;
              cursor: pointer;
              font-size: 14px;
            ">‚å®Ô∏è Manual Entry</button>
            <button onclick="closeQRScanner()" style="
              background-color: #6c757d;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 8px 16px;
              cursor: pointer;
              font-size: 14px;
            ">‚ùå Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Controls section with aligned buttons -->
    <div class="controls" style="margin-top: 10px">
      <!-- Financial inputs group -->
      <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap">
        <label for="pointValue">Point Value: ‚Çπ</label>
        <input type="number" id="pointValue" min="0" step="0.01" value="1.00" style="width: 80px"
          onchange="saveData();" />

        <label for="gstPercent">GST%: </label>
        <input type="number" id="gstPercent" min="0" max="100" step="0.01" value="18.00" style="width: 80px"
          onchange="saveData();" />
      </div>

      <!-- Action buttons group -->
      <div style="display: flex; gap: 10px; flex-wrap: wrap">
        <button onclick="loadFromCloud()" style="background-color: #17a2b8">
          ÔøΩ Scan QR / Load Game
        </button>
        <button class="start-play-button" onclick="startNewGame()">
          üéÆ Start Play
        </button>
        <button id="closeGameButton" onclick="confirmCloseGame()" style="background-color: #dc3545; display: none">
          üóëÔ∏è Close Game
        </button>
      </div>
    </div>

    <div id="scoreTableContainer"></div>
    <div class="leaderboard" id="leaderboard"></div>
    <div class="chart-container">
      <canvas id="scoreChart"></canvas>
    </div>
  </div>
  <!-- Custom Confirmation Modal -->
  <div id="confirmModal" class="modal">
    <div class="modal-content">
      <h3 id="modalTitle">‚ö†Ô∏è Confirm Action</h3>
      <p id="modalMessage">Are you sure you want to proceed?</p>
      <div class="modal-buttons">
        <button class="modal-button confirm" onclick="confirmAction()">
          Yes, Proceed
        </button>
        <button class="modal-button cancel" onclick="closeModal()">
          Cancel
        </button>
      </div>
    </div>
  </div>
  <!-- Add Firebase SDK before your existing script -->
  <script type="module">
    // Import Firebase modules
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getFirestore,
      doc,
      setDoc,
      getDoc,
      serverTimestamp,
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    // Your Firebase configuration (paste the config you copied from Step 1)
    const firebaseConfig = {
      apiKey: "AIzaSyD6vyITxs4RUKSZt5K6ZhfKqXavgO7CcYU",
      authDomain: "rummy-score-master.firebaseapp.com",
      projectId: "rummy-score-master",
      storageBucket: "rummy-score-master.firebasestorage.app",
      messagingSenderId: "740379545501",
      appId: "1:740379545501:web:48fd959b916386299c2974",
      measurementId: "G-5TVE05Q9Q5",
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Make Firebase available globally
    window.db = db;
    window.firestore = { doc, setDoc, getDoc, serverTimestamp };

    console.log("Firebase initialized successfully!");
  </script>
  <!-- QR Code Scanner Library -->
  <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
  <!-- Your existing script tag starts here -->
  <script>
    let chart;
    let pendingAction = null;

    function showModal(title, message, action) {
      document.getElementById("modalTitle").textContent = title;
      document.getElementById("modalMessage").textContent = message;
      document.getElementById("confirmModal").style.display = "block";
      pendingAction = action;
    }

    function closeModal() {
      document.getElementById("confirmModal").style.display = "none";
      pendingAction = null;
    }

    function confirmAction() {
      if (pendingAction) {
        pendingAction();
      }
      closeModal();
    }

    function saveData() {
      // Prevent saving in view-only mode
      if (isViewOnlyMode) {
        console.log("Save blocked - View Only Mode");
        return;
      }

      // Get number of players from the actual table instead of input
      const playerRows =
        document.querySelectorAll('input[id^="name"]').length;
      const pointValue =
        parseFloat(document.getElementById("pointValue").value) || 1.0;
      const gstPercent =
        parseFloat(document.getElementById("gstPercent").value) || 18.0;

      const data = {
        numPlayers: playerRows,
        pointValue,
        gstPercent,
        players: [],
      };

      for (let i = 1; i <= playerRows; i++) {
        const nameInput = document.getElementById(`name${i}`);
        if (nameInput) {
          const name = nameInput.value.trim();
          const scores = [];
          for (let j = 1; j <= 10; j++) {
            const scoreInput = document.getElementById(`p${i}r${j}`);
            const val = scoreInput ? parseInt(scoreInput.value) : -1;
            scores.push(isNaN(val) ? -1 : val);
          }
          data.players.push({ name, scores });
        }
      }
      localStorage.setItem("scoreData", JSON.stringify(data));

      // Add auto-save to cloud
      autoSaveToCloud();
    }

    // Add function to disable game settings after start
    function disableGameSettingsAfterStart() {
      const gstInput = document.getElementById("gstPercent");
      const pointValueInput = document.getElementById("pointValue");
      const loadButton = document.querySelector(
        'button[onclick="loadFromCloud()"]'
      );
      const startButton = document.querySelector(".start-play-button");
      const closeButton = document.getElementById("closeGameButton");

      if (gstInput) {
        gstInput.disabled = true;
        gstInput.style.opacity = "0.6";
        gstInput.style.cursor = "not-allowed";
        gstInput.title = "GST percentage cannot be changed after game starts";
      }

      // Disable Point Value input
      if (pointValueInput) {
        pointValueInput.disabled = true;
        pointValueInput.style.opacity = "0.6";
        pointValueInput.style.cursor = "not-allowed";
        pointValueInput.title =
          "Point value cannot be changed after game starts";
      }

      if (loadButton) {
        loadButton.disabled = true;
        loadButton.style.opacity = "0.6";
        loadButton.style.cursor = "not-allowed";
        loadButton.textContent = "ÔøΩ Scan QR / Load Game (Disabled)";
        loadButton.title =
          "Cannot load new game while current game is in progress";
      }

      // Disable Start Play button
      if (startButton) {
        startButton.disabled = true;
        startButton.style.opacity = "0.6";
        startButton.style.cursor = "not-allowed";
        startButton.textContent = "üéÆ Game In Progress";
        startButton.title =
          "Game is already in progress. Close game to start new one.";
      }

      // Show close game button
      if (closeButton) {
        closeButton.style.display = "inline-block";
      }
    }

    // Add function to enable game settings (for new games)
    function enableGameSettings() {
      const gstInput = document.getElementById("gstPercent");
      const pointValueInput = document.getElementById("pointValue");
      const loadButton = document.querySelector(
        'button[onclick="loadFromCloud()"]'
      );
      const startButton = document.querySelector(".start-play-button");
      const closeButton = document.getElementById("closeGameButton");

      if (gstInput) {
        gstInput.disabled = false;
        gstInput.style.opacity = "1";
        gstInput.style.cursor = "text";
        gstInput.title = "";
      }

      // Re-enable Point Value input
      if (pointValueInput) {
        pointValueInput.disabled = false;
        pointValueInput.style.opacity = "1";
        pointValueInput.style.cursor = "text";
        pointValueInput.title = "";
      }

      if (loadButton) {
        loadButton.disabled = false;
        loadButton.style.opacity = "1";
        loadButton.style.cursor = "pointer";
        loadButton.textContent = "ÔøΩ Scan QR / Load Game";
        loadButton.title = "";
      }

      // Re-enable Start Play button
      if (startButton) {
        startButton.disabled = false;
        startButton.style.opacity = "1";
        startButton.style.cursor = "pointer";
        startButton.textContent = "üéÆ Start Play";
        startButton.title = "";
      }

      // Hide close game button
      if (closeButton) {
        closeButton.style.display = "none";
      }
    }

    function loadData() {
      const saved = localStorage.getItem("scoreData");
      if (!saved) {
        // No saved data - enable settings and reset view-only mode
        isViewOnlyMode = false;
        removeViewOnlyIndicator();
        enableGameSettings();
        return;
      }

      const data = JSON.parse(saved);

      document.getElementById("pointValue").value = data.pointValue || 1.0;
      document.getElementById("gstPercent").value = data.gstPercent || 18.0;

      generateTable(data);

      // Update Game ID display
      updateGameIdDisplay();

      // Disable settings since game is already started
      disableGameSettingsAfterStart();
    }

    function startNewGame() {
      // Check if Start Play button is already disabled
      const startButton = document.querySelector(".start-play-button");
      if (startButton && startButton.disabled) {
        return; // Prevent action if button is disabled
      }

      // Just start the game directly
      localStorage.removeItem("scoreData");
      localStorage.removeItem("gameId");
      localStorage.removeItem("gamePin");

      // Reset view-only mode for new games
      isViewOnlyMode = false;
      removeViewOnlyIndicator();

      // Generate new Game ID
      const gameId = Math.random().toString(36).substr(2, 9).toUpperCase();
      localStorage.setItem("gameId", gameId);

      // Generate a random 4-digit PIN (string, leading zeros allowed), never '0000'
      let pin;
      do {
        pin = ("000" + Math.floor(Math.random() * 10000)).slice(-4);
      } while (pin === "0000");
      localStorage.setItem("gamePin", pin);
      console.log("Generated PIN for new game:", pin);

      generateTable();
      updateGameIdDisplay();
      disableGameSettingsAfterStart();

      // Save initial game state to cloud with PIN only (no device info)
      saveInitialGameStateToCloud(pin);
    }

    // ...existing code...

    // Add helper function to save initial game state to cloud with separate collections
    async function saveInitialGameStateToCloud(pin) {
      const gameId = localStorage.getItem("gameId");
      const data = localStorage.getItem("scoreData");

      // Only save if we have gameId and Firebase is ready
      if (!gameId || !window.db) {
        return; // Skip cloud save if no gameId or Firebase not ready
      }

      try {
        // Parse existing data or create empty structure
        const gameData = data
          ? JSON.parse(data)
          : {
            numPlayers: 2,
            pointValue:
              parseFloat(document.getElementById("pointValue").value) ||
              1.0,
            gstPercent:
              parseFloat(document.getElementById("gstPercent").value) ||
              18.0,
            players: [],
          };

        // Save authentication data to 'games' collection (ID + PIN only)
        await window.firestore.setDoc(
          window.firestore.doc(window.db, "games", gameId),
          {
            gameId: gameId,
            pin: pin || localStorage.getItem("gamePin") || "0000", // Fallback to "0000" if PIN is somehow missing
            createdAt: window.firestore.serverTimestamp(),
            version: "1.0",
          }
        );

        // Save game data to 'gameData' collection (scores and settings)
        await window.firestore.setDoc(
          window.firestore.doc(window.db, "gameData", gameId),
          {
            data: gameData,
            lastUpdated: window.firestore.serverTimestamp(),
            version: "1.0",
          }
        );

        console.log("Initial game state saved - Games collection (auth):", gameId, "PIN:", pin || localStorage.getItem("gamePin"));
        console.log("Initial game state saved - GameData collection (data):", gameId);
      } catch (error) {
        console.error("Failed to save initial game state to cloud:", error);
        // Don't show error to user, just log it
      }
    }

    function addPlayer() {
      // Prevent adding players in view-only mode
      if (isViewOnlyMode) {
        showToast("‚ùå Cannot add players in View Only mode", "error");
        return;
      }

      // Get current number of players from existing table
      const currentPlayers =
        document.querySelectorAll('input[id^="name"]').length;

      if (currentPlayers >= 15) {
        showModal(
          "‚ö†Ô∏è Maximum Players Reached",
          "Maximum 15 players allowed!",
          null
        );
        return;
      }

      // Save current data first
      saveData();

      // Get existing data and add one more player
      const saved = localStorage.getItem("scoreData");
      let savedData = null;

      if (saved) {
        savedData = JSON.parse(saved);
        // Increment the number of players
        savedData.numPlayers = currentPlayers + 1;
      }

      // Regenerate table with existing data preserved + 1 new player
      generateTable(savedData);
    }

    // Update the generateTable function to include the Add Player button at the end
    function generateTable(savedData = null) {
      let numPlayers;

      if (savedData && savedData.numPlayers) {
        numPlayers = savedData.numPlayers;
      } else {
        // Get current players or default to 2
        const existingPlayers =
          document.querySelectorAll('input[id^="name"]').length;
        numPlayers = existingPlayers > 0 ? existingPlayers + 1 : 2;
      }

      // Get existing data if not provided
      if (!savedData) {
        const saved = localStorage.getItem("scoreData");
        if (saved) {
          savedData = JSON.parse(saved);
        }
      }

      let html = `
<h2>Score</h2>
<div class="table-container">
  <table>
    <thead>
      <tr style="background-color: #f8f9fa;">
        <th style="border: 1px solid #ccc; padding: 8px; text-align: left;">Player Name</th>`;

      for (let round = 1; round <= 10; round++) {
        html += `<th style="border: 1px solid #ccc; padding: 8px; text-align: center;">R${round}</th>`;
      }
      html += `</tr></thead><tbody>`;

      for (let i = 1; i <= numPlayers; i++) {
        const name =
          savedData && savedData.players && savedData.players[i - 1]
            ? savedData.players[i - 1].name
            : `Player ${i}`;

        html += `<tr><td style="border: 1px solid #ccc; padding: 8px;"><input type="text" id="name${i}" value="${name}" style="border: none; background: transparent; width: 100%; padding: 4px; font-size: 14px;"></td>`;

        for (let j = 1; j <= 10; j++) {
          const val =
            savedData &&
              savedData.players &&
              savedData.players[i - 1] &&
              savedData.players[i - 1].scores
              ? savedData.players[i - 1].scores[j - 1] !== undefined
                ? savedData.players[i - 1].scores[j - 1]
                : -1
              : -1;
          html += `<td style="border: 1px solid #ccc; padding: 8px; text-align: center; min-width: 60px;"><input type="number" id="p${i}r${j}" value="${val}" min="-1" max="100" style="border: none; background: transparent; width: 100%; text-align: center; padding: 4px; font-size: 14px; min-width: 50px;"></td>`;
        }
        html += "</tr>";
      }

      html += "</tbody></table></div>";

      // Add the "Add Player" button after the table
      html += `
<div style="margin-top: 10px;">
  <button onclick="addPlayer()" class="add-player-btn" style="padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
    + Add Player
  </button>
</div>`;

      document.getElementById("scoreTableContainer").innerHTML = html;

      // Add event listeners to inputs (only if not in view-only mode)
      if (!isViewOnlyMode) {
        addInputEventListeners();
      }

      // Apply color coding to existing scores
      colorScoreInputs();

      // Apply view-only restrictions if in view-only mode
      if (isViewOnlyMode) {
        applyViewOnlyRestrictions();
      }

      // Save the new state and calculate scores
      saveData();
      calculateScores();

      // Update Game ID display
      updateGameIdDisplay();
    }

    // Function to add event listeners to input fields
    function addInputEventListeners() {
      // Add listeners to name inputs
      const nameInputs = document.querySelectorAll('input[id^="name"]');
      nameInputs.forEach(input => {
        input.addEventListener('input', function() {
          if (!isViewOnlyMode) {
            saveData();
            calculateScores();
          }
        });
      });

      // Add listeners to score inputs
      const scoreInputs = document.querySelectorAll('input[id^="p"][id*="r"]');
      scoreInputs.forEach(input => {
        input.addEventListener('input', function() {
          if (!isViewOnlyMode) {
            saveData();
            calculateScores();
            colorScoreInputs();
          }
        });
      });
    }

    // Update the colorScoreInputs function with new thresholds
    function colorScoreInputs() {
      const numPlayers =
        document.querySelectorAll('input[id^="name"]').length;

      for (let i = 1; i <= numPlayers; i++) {
        for (let j = 1; j <= 10; j++) {
          const input = document.getElementById(`p${i}r${j}`);
          if (input) {
            const val = parseInt(input.value);

            if (isNaN(val) || val === -1) {
              input.style.color = "#6c757d"; // Gray for -1
              input.style.fontStyle = "italic";
            } else if (val < 40) {
              input.style.color = "#28a745"; // Green for low scores (good)
              input.style.fontStyle = "normal";
            } else if (val >= 40 && val <= 60) {
              input.style.color = "#ffc107"; // Yellow for medium scores
              input.style.fontStyle = "normal";
            } else {
              input.style.color = "#dc3545"; // Red for high scores (bad)
              input.style.fontStyle = "normal";
            }
          }
        }
      }
    }

    // Update the calculateScores function to remove settlement info from leaderboard
    function calculateScores() {
      // Get number of players from actual table
      const numPlayers =
        document.querySelectorAll('input[id^="name"]').length;
      const scores = [];
      const pointValue =
        parseFloat(document.getElementById("pointValue").value) || 1.0;
      const gstPercent =
        parseFloat(document.getElementById("gstPercent").value) || 18.0;

      for (let i = 1; i <= numPlayers; i++) {
        let total = 0;
        for (let j = 1; j <= 10; j++) {
          const scoreInput = document.getElementById(`p${i}r${j}`);
          if (scoreInput) {
            const val = parseInt(scoreInput.value);
            total += isNaN(val) || val === -1 ? 0 : val;
          }
        }
        const nameInput = document.getElementById(`name${i}`);
        const name = nameInput ? nameInput.value.trim() : `Player ${i}`;
        scores.push({ name, total });
      }

      // Keep original order for chart
      const originalOrderScores = [...scores];

      // Sort for leaderboard (low score wins)
      const sortedScores = [...scores].sort((a, b) => a.total - b.total);

      // Calculate total of all scores
      const totalAllScores = sortedScores.reduce(
        (sum, score) => sum + score.total,
        0
      );

      // Calculate gross amounts and GST using correct Rummy formula
      sortedScores.forEach((score) => {
        // Formula: (Total of all scores - Player's score √ó Number of players) √ó Point value
        score.grossAmount =
          Math.round((totalAllScores - score.total * numPlayers) * pointValue);

        // GST is only paid by winners (those with positive gross amount)
        if (score.grossAmount > 0) {
          score.gstPaid = Math.round((score.grossAmount * gstPercent) / 100);
          score.netAmount = score.grossAmount - score.gstPaid;
        } else {
          score.gstPaid = 0; // Losers don't pay GST
          score.netAmount = score.grossAmount; // Same as gross for losers
        }
      });

      // Calculate total GST collected
      const totalGstCollected = sortedScores.reduce(
        (sum, score) => sum + score.gstPaid,
        0
      );

      // Create leaderboard table WITHOUT settlement explanation
      let leaderboardHtml = `
<h2>Leaderboard & Settlement</h2>
<table class="leaderboard-table" style="
  width: auto !important; 
  min-width: auto !important; 
  max-width: 650px !important; 
  border-collapse: collapse; 
  margin-top: 10px; 
  display: table !important;
  table-layout: auto !important;
">
  <thead>
    <tr style="background: linear-gradient(135deg, #212529, #343a40) !important;">
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 50px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Rank</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: left; width: auto !important; min-width: 80px !important; max-width: 100px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Player</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 50px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Score</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Gross Amount</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 65px !important; font-size: 12px; color: white !important; font-weight: bold !important;">GST (${gstPercent}%)</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Net Amount</th>
    </tr>
  </thead>
  <tbody>`;

      sortedScores.forEach((score, index) => {
        // Add medal icons with rank numbers
        let rankDisplay;
        if (index === 0) {
          rankDisplay = "ü•á";
        } else if (index === 1) {
          rankDisplay = "ü•à";
        } else if (index === 2) {
          rankDisplay = "ü•â";
        } else {
          rankDisplay = `${index + 1}`;
        }

        const grossAmount = score.grossAmount;
        const gstPaid = score.gstPaid;
        const netAmount = score.netAmount;

        // Determine if this is a winner or loser for styling
        const isWinner = grossAmount > 0;
        const isLoser = grossAmount < 0;

        let grossStyle = "";
        let gstStyle = "";
        let netStyle = "";

        if (isWinner) {
          grossStyle = "color: #28a745; font-weight: bold;"; // Green for receiving money
          gstStyle = "color: #dc3545; font-weight: bold;"; // Red for GST paid
          netStyle = "color: #28a745; font-weight: bold;"; // Green for net amount received
        } else if (isLoser) {
          grossStyle = "color: #dc3545; font-weight: bold;"; // Red for paying money
          gstStyle = "color: #6c757d;"; // Gray for no GST
          netStyle = "color: #dc3545; font-weight: bold;"; // Red for net amount paid
        } else {
          grossStyle = "color: #6c757d;"; // Gray for break-even
          gstStyle = "color: #6c757d;"; // Gray for no GST
          netStyle = "color: #6c757d;"; // Gray for break-even
        }

        leaderboardHtml += `
  <tr>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; font-weight: bold; width: 50px !important; font-size: 11px;">${rankDisplay}</td>
    <td style="border: 1px solid #ccc; padding: 6px; width: auto !important; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${score.name
          }</td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 50px !important; font-size: 11px; font-weight: 600;">${score.total
          }</td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 11px; ${grossStyle}">‚Çπ${grossAmount}</td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 65px !important; font-size: 11px; ${gstStyle}">‚Çπ${gstPaid}</td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 11px; ${netStyle}">‚Çπ${netAmount}</td>
  </tr>`;
      });

      leaderboardHtml += `
  </tbody>
  <tfoot>
    <tr style="background-color: #e9ecef; font-weight: bold;">
      <td colspan="4" style="border: 1px solid #ccc; padding: 6px; text-align: right; font-size: 12px; color: #6c757d;">Total GST Collected:</td>
      <td style="border: 1px solid #ccc; padding: 6px; text-align: center; font-size: 12px; color: #28a745; font-weight: bold;">‚Çπ${Math.round(totalGstCollected)}</td>
      <td style="border: 1px solid #ccc; padding: 6px; text-align: center; font-size: 12px; color: #6c757d;">-</td>
    </tr>
  </tfoot>
</table>`;

      document.getElementById("leaderboard").innerHTML = leaderboardHtml;
      updateChart(originalOrderScores); // Pass original order to chart

      // Color code the leaderboard scores
      sortedScores.forEach((score, index) => {
        const scoreCell = document.querySelector(
          `.leaderboard-table tbody tr:nth-child(${index + 1
          }) td:nth-child(3)`
        );
        if (scoreCell) {
          if (score.total < 40) {
            scoreCell.style.color = "#28a745"; // Green for good scores
          } else if (score.total >= 40 && score.total <= 60) {
            scoreCell.style.color = "#ffc107"; // Yellow for medium scores
          } else {
            scoreCell.style.color = "#dc3545"; // Red for high scores
          }
        }
      });

      // Add settlement explanation AFTER chart is updated
      updateSettlementInfo(gstPercent, numPlayers, pointValue);
    }

    function updateChart(scores) {
      const ctx = document.getElementById("scoreChart").getContext("2d");
      const labels = scores.map((s) => s.name);
      const data = scores.map((s) => s.total);

      // Find min and max scores for relative coloring
      const minScore = Math.min(...data);
      const maxScore = Math.max(...data);
      const range = maxScore - minScore;

      const backgroundColors = data.map((score) => {
        if (range === 0) {
          // All scores are the same
          return "rgb(128, 128, 128)"; // Gray
        }

        // Calculate relative position (0 = best, 1 = worst)
        const position = (score - minScore) / range;

        if (position <= 0.33) {
          // Best third - Green shades (darker green for better scores)
          const green = Math.round(255 - position * 0.33 * 100); // 255 to 155
          return `rgb(0, ${green}, 0)`;
        } else if (position <= 0.66) {
          // Middle third - Yellow/Orange shades
          const progress = (position - 0.33) / 0.33; // 0 to 1 within this range
          const red = Math.round(255);
          const green = Math.round(255 - progress * 127); // 255 to 128
          return `rgb(${red}, ${green}, 0)`;
        } else {
          // Worst third - Red shades (darker red for worse scores)
          const progress = (position - 0.66) / 0.34; // 0 to 1 within this range
          const red = Math.round(200 + progress * 55); // 200 to 255
          return `rgb(${red}, 0, 0)`;
        }
      });

      if (chart) chart.destroy();

      chart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              label: "Total Score",
              data: data,
              backgroundColor: backgroundColors,
              borderColor: "rgba(0,0,0,0.2)",
              borderWidth: 1,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              display: false,
            },
          },
          scales: {
            y: {
              beginAtZero: true,
            },
            x: {
              // Removed title
            },
          },
        },
      });

      // After chart is rendered, add settlement info
      setTimeout(() => {
        // Get current values for settlement info
        const gstPercent =
          parseFloat(document.getElementById("gstPercent").value) || 18.0;
        const numPlayers =
          document.querySelectorAll('input[id^="name"]').length;
        const pointValue =
          parseFloat(document.getElementById("pointValue").value) || 1.0;
        updateSettlementInfo(gstPercent, numPlayers, pointValue);
      }, 100);
    }

    // New function to add settlement info after the chart
    function updateSettlementInfo(gstPercent, numPlayers, pointValue) {
      // Remove existing settlement info if any
      const existingInfo = document.getElementById("settlementInfo");
      if (existingInfo) {
        existingInfo.remove();
      }

      // Create settlement explanation
      const settlementHtml = `
<div id="settlementInfo" style="margin-top: 30px; padding: 15px; background-color: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
  <h4 style="margin: 0 0 12px 0; color: #495057; font-size: 16px;">üí° How Settlement Works:</h4>
  <ul style="margin: 0; padding-left: 20px; font-size: 14px; color: #6c757d; line-height: 1.5;">
    <li><strong style="color: #28a745;">Winners (Green):</strong> Receive money but pay ${gstPercent}% GST on winnings</li>
    <li><strong style="color: #dc3545;">Losers (Red):</strong> Pay money, no GST required</li>
    <li><strong>Formula:</strong> (Total All Scores - Your Score √ó ${numPlayers}) √ó ‚Çπ${pointValue}</li>
    <li><strong>GST:</strong> Only winners pay ${gstPercent}% GST on positive amounts</li>
    <li><strong>Net Amount:</strong> Gross Amount - GST (for winners) or just Gross Amount (for losers)</li>
  </ul>
  <div style="margin-top: 10px; padding: 8px; background-color: #e3f2fd; border-radius: 4px; font-size: 12px; color: #1565c0;">
    <strong>üí∞ Example:</strong> If you score 25 points in a ${numPlayers}-player game with ‚Çπ${pointValue}/point:<br>
    Your settlement = (Total of all ${numPlayers} scores - 25 √ó ${numPlayers}) √ó ‚Çπ${pointValue}
  </div>
</div>`;

      // Add after the chart container
      const chartContainer = document.querySelector(".chart-container");
      if (chartContainer) {
        chartContainer.insertAdjacentHTML("afterend", settlementHtml);
      }
    }

    // Add these cloud functions after your existing functions

    // Generate or get game ID (no cloud operations)
    function getGameId() {
      let gameId = localStorage.getItem("gameId");
      if (!gameId) {
        gameId = Math.random().toString(36).substr(2, 9).toUpperCase();
        localStorage.setItem("gameId", gameId);
      }
      return gameId;
    }

    // Save to cloud - saves to gameData collection only
    async function saveToCloud() {
      // Prevent saving in view-only mode
      if (isViewOnlyMode) {
        showToast("‚ùå Cannot save in View Only mode", "error");
        return;
      }

      if (!window.db) {
        showToast(
          "‚ùå Firebase Not Ready - Please refresh the page!",
          "error"
        );
        return;
      }

      const gameId = getGameId();
      const data = localStorage.getItem("scoreData");

      if (!data) {
        showToast("‚ö†Ô∏è No game data to save to cloud!", "error");
        return;
      }

      try {
        const loadingToast = showToast(
          "‚òÅÔ∏è Saving game to cloud...",
          "loading"
        );

        // Save data to gameData collection only
        const gameDataRef = window.firestore.doc(window.db, "gameData", gameId);
        
        await window.firestore.setDoc(gameDataRef, {
          data: JSON.parse(data),
          lastUpdated: window.firestore.serverTimestamp(),
          version: "1.0",
        });

        hideLoadingToast();
        showToast(`‚úÖ Game saved! ID: ${gameId}`, "success", 6000);
      } catch (error) {
        console.error("Save error:", error);
        hideLoadingToast();
        showToast(
          "‚ùå Failed to save. Check your internet connection.",
          "error"
        );
      }
    }

    // Load from cloud - with QR code scanner
    async function loadFromCloud() {
      if (!window.db) {
        showToast(
          "‚ùå Firebase Not Ready - Please refresh the page!",
          "error"
        );
        return;
      }

      // Check if device has camera support
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        // Fallback to text input for devices without camera
        const gameId = prompt("Enter Game ID to load game (Camera not supported):");
        if (gameId) {
          await loadGameById(gameId.trim().toUpperCase());
        }
        return;
      }

      // Open QR scanner modal and automatically start camera
      document.getElementById("qrScannerModal").style.display = "block";
      
      // Reset mode selection and PIN verification state
      currentScanMode = "view";
      isPINVerified = false;
      
      // Reset radio buttons to View Only as default
      const viewRadio = document.querySelector('input[name="scanMode"][value="view"]');
      if (viewRadio) {
        viewRadio.checked = true;
      }
      
      // Hide PIN container initially
      const pinContainer = document.getElementById("pinContainer");
      const pinInput = document.getElementById("pinInput");
      const pinMessage = document.getElementById("pinMessage");
      if (pinContainer) {
        pinContainer.style.display = "none";
      }
      if (pinInput) {
        pinInput.value = "";
      }
      if (pinMessage) {
        pinMessage.textContent = "";
      }
      
      // Clear any temporary game ID
      window.tempGameId = null;
      
      // Automatically start the camera
      setTimeout(() => {
        startQRScanner();
      }, 100); // Small delay to ensure modal is fully displayed
    }

    // QR Scanner variables
    let qrStream = null;
    let qrScanInterval = null;
    let currentCamera = "environment"; // "environment" for back camera, "user" for front camera

    // Variables to store mode and PIN verification state
    let currentScanMode = "view";
    let isPINVerified = false;
    let isViewOnlyMode = false; // Global flag to track if game is in view-only mode

    // PIN validation function - reads from games collection only
    async function validatePIN(enteredPIN) {
      const pinMessage = document.getElementById("pinMessage");
      const gameId = localStorage.getItem("gameId") || getCurrentGameIdFromScanner();
      
      if (!gameId) {
        pinMessage.textContent = "‚ö†Ô∏è Please scan QR code first to get Game ID";
        pinMessage.style.color = "#dc3545";
        return;
      }

      if (!window.db) {
        pinMessage.textContent = "‚ùå Database not ready. Please try again.";
        pinMessage.style.color = "#dc3545";
        return;
      }

      try {
        pinMessage.textContent = "üîç Verifying PIN...";
        pinMessage.style.color = "#007bff";

        // Fetch PIN from games collection (authentication data only)
        const authDocSnap = await window.firestore.getDoc(
          window.firestore.doc(window.db, "games", gameId)
        );

        if (authDocSnap.exists()) {
          const authData = authDocSnap.data();
          const storedPIN = authData.pin;

          if (storedPIN === enteredPIN) {
            // PIN matches - immediately set PIN in localStorage to prevent race conditions
            localStorage.setItem("gamePin", storedPIN);
            console.log("PIN validation success - stored PIN in localStorage:", storedPIN);
            
            pinMessage.textContent = "‚úÖ PIN matched! You are in Edit Mode";
            pinMessage.style.color = "#28a745";
            isPINVerified = true;
            currentScanMode = "edit";
            
            // Close scanner and load game in edit mode
            setTimeout(() => {
              closeQRScanner();
              loadGameById(gameId, "edit");
            }, 1000);
          } else {
            // PIN doesn't match
            pinMessage.textContent = "‚ùå PIN not matched. Switching to View Mode";
            pinMessage.style.color = "#dc3545";
            isPINVerified = false;
            currentScanMode = "view";
            
            // Switch to view mode radio button
            const viewRadio = document.querySelector('input[name="scanMode"][value="view"]');
            if (viewRadio) {
              viewRadio.checked = true;
            }
            
            // Hide PIN container after failed attempt
            setTimeout(() => {
              document.getElementById("pinContainer").style.display = "none";
            }, 2000);
          }
        } else {
          pinMessage.textContent = "‚ùå Game not found in cloud database";
          pinMessage.style.color = "#dc3545";
          isPINVerified = false;
          currentScanMode = "view";
        }
      } catch (error) {
        console.error("PIN validation error:", error);
        pinMessage.textContent = "‚ùå PIN verification failed. Network error.";
        pinMessage.style.color = "#dc3545";
        isPINVerified = false;
        currentScanMode = "view";
      }
    }

    // Helper function to get current game ID from scanner context
    function getCurrentGameIdFromScanner() {
      // This will be set when QR code is scanned but before loading
      return window.tempGameId || null;
    }

    // Manual entry function
    function manualEntry() {
      // Get the current selected mode before closing scanner
      const selectedMode = document.querySelector('input[name="scanMode"]:checked').value;
      
      closeQRScanner();
      
      const gameId = prompt("Enter Game ID to load game:");
      if (gameId && gameId.trim()) {
        const cleanGameId = gameId.trim().toUpperCase();
        
        if (selectedMode === "view") {
          // View mode - load directly
          currentScanMode = "view";
          isPINVerified = false;
          loadGameById(cleanGameId, "view");
        } else {
          // Edit mode - prompt for PIN
          const enteredPIN = prompt("Enter 4-digit PIN for Edit access:");
          if (enteredPIN && enteredPIN.trim().length === 4) {
            // Store game ID temporarily and validate PIN
            window.tempGameId = cleanGameId;
            validatePINAndLoad(cleanGameId, enteredPIN.trim());
          } else if (enteredPIN !== null) {
            // User entered invalid PIN format
            showToast("‚ùå Invalid PIN format. Please enter a 4-digit PIN.", "error");
          }
          // If user cancelled PIN prompt, do nothing
        }
      }
    }

    // Helper function for manual entry PIN validation - reads from games collection only
    async function validatePINAndLoad(gameId, enteredPIN) {
      if (!window.db) {
        showToast("‚ùå Database not ready. Please try again.", "error");
        return;
      }

      try {
        showToast("üîç Verifying PIN...", "loading");

        // Fetch PIN from games collection (authentication data only)
        const authDocSnap = await window.firestore.getDoc(
          window.firestore.doc(window.db, "games", gameId)
        );

        if (authDocSnap.exists()) {
          const authData = authDocSnap.data();
          const storedPIN = authData.pin;

          if (storedPIN === enteredPIN) {
            // PIN matches - immediately set PIN in localStorage to prevent race conditions
            localStorage.setItem("gamePin", storedPIN);
            console.log("Manual entry PIN validation success - stored PIN in localStorage:", storedPIN);
            
            isPINVerified = true;
            currentScanMode = "edit";
            hideLoadingToast();
            loadGameById(gameId, "edit");
          } else {
            // PIN doesn't match
            hideLoadingToast();
            showToast("‚ùå PIN not matched. Loading in View Only mode instead.", "error", 6000);
            isPINVerified = false;
            currentScanMode = "view";
            loadGameById(gameId, "view");
          }
        } else {
          hideLoadingToast();
          showToast("‚ùå Game not found in cloud database", "error");
        }
      } catch (error) {
        console.error("PIN validation error:", error);
        hideLoadingToast();
        showToast("‚ùå PIN verification failed. Loading in View Only mode.", "error", 6000);
        isPINVerified = false;
        currentScanMode = "view";
        loadGameById(gameId, "view");
      }
    }

    // Switch camera function
    async function switchCamera() {
      const switchBtn = document.getElementById("switchCameraBtn");
      const statusText = document.getElementById("scannerStatus");
      
      // Disable button temporarily
      switchBtn.disabled = true;
      switchBtn.textContent = "üîÑ Switching...";
      
      // Stop current stream
      if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
      }
      
      // Clear scanning interval
      if (qrScanInterval) {
        clearInterval(qrScanInterval);
        qrScanInterval = null;
      }
      
      // Switch camera
      currentCamera = currentCamera === "environment" ? "user" : "environment";
      
      // Restart scanner with new camera
      try {
        await startQRScanner();
        switchBtn.textContent = currentCamera === "environment" ? "üì± Front Camera" : "üìπ Back Camera";
      } catch (error) {
        statusText.textContent = "‚ùå Failed to switch camera";
        statusText.style.color = "#dc3545";
        switchBtn.textContent = "üîÑ Switch Camera";
      }
      
      switchBtn.disabled = false;
    }

    // Start QR Scanner
    async function startQRScanner() {
      const video = document.getElementById("qrScannerVideo");
      const canvas = document.getElementById("qrScannerCanvas");
      const context = canvas.getContext("2d");
      const statusText = document.getElementById("scannerStatus");

      try {
        // Update status
        statusText.textContent = "üì∑ Starting camera...";
        statusText.style.color = "#007bff";

        // Request camera access
        qrStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: currentCamera, // Use current camera setting
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        video.srcObject = qrStream;
        video.play();

        // Show switch camera button once camera is working
        const switchBtn = document.getElementById("switchCameraBtn");
        if (switchBtn) {
          switchBtn.style.display = "inline-block";
          switchBtn.textContent = currentCamera === "environment" ? "üì± Front Camera" : "üìπ Back Camera";
        }

        // Update status
        statusText.textContent = "üîç Scanning for QR code... Position it within the green frame";
        statusText.style.color = "#28a745";

        // Wait for video to load
        video.addEventListener("loadedmetadata", () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;

          // Start scanning for QR codes
          qrScanInterval = setInterval(() => {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
              context.drawImage(video, 0, 0, canvas.width, canvas.height);
              const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
              
              // Use jsQR library to decode QR code
              const code = jsQR(imageData.data, imageData.width, imageData.height);
              
              if (code && code.data) {
                // QR code found! Update visual feedback
                const scannerFrame = document.getElementById("scannerFrame");
                if (scannerFrame) {
                  scannerFrame.style.borderColor = "#ffc107";
                  scannerFrame.style.background = "rgba(255, 193, 7, 0.2)";
                  scannerFrame.innerHTML = `
                    <div style="
                      color: #ffc107;
                      font-size: 18px;
                      font-weight: bold;
                      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                      text-align: center;
                      padding: 10px;
                    ">
                      ‚úÖ QR Code Found!<br>
                      <small>Processing...</small>
                    </div>
                  `;
                }
                
                // Get the selected mode
                const selectedMode = document.querySelector('input[name="scanMode"]:checked').value;
                const gameId = code.data.trim().toUpperCase();
                
                // Store the game ID temporarily for PIN validation
                window.tempGameId = gameId;
                
                if (selectedMode === "view") {
                  // View mode - no PIN required
                  statusText.textContent = "‚úÖ QR Code detected! Loading in View Only mode...";
                  statusText.style.color = "#28a745";
                  showToast(`üëÅÔ∏è Loading in View Only mode - Game ID: ${gameId}`, "info", 4000);
                  currentScanMode = "view";
                  isPINVerified = false;
                  closeQRScanner();
                  loadGameById(gameId);
                } else {
                  // Edit mode - PIN verification required
                  statusText.textContent = "‚úÖ QR Code detected! Please verify PIN for Edit access...";
                  statusText.style.color = "#ffc107";
                  
                  // Stop scanning since we found the QR code
                  clearInterval(qrScanInterval);
                  qrScanInterval = null;
                  
                  // Show PIN message and focus on PIN input
                  const pinInput = document.getElementById("pinInput");
                  const pinMessage = document.getElementById("pinMessage");
                  
                  if (pinMessage) {
                    pinMessage.textContent = `üîê Enter PIN for Game ID: ${gameId}`;
                    pinMessage.style.color = "#007bff";
                  }
                  
                  if (pinInput) {
                    pinInput.focus();
                    pinInput.select();
                  }
                  
                  showToast(`üîê QR Code found! Enter PIN to access Edit mode`, "info", 6000);
                }
              }
            }
          }, 300); // Check every 300ms
        });

      } catch (error) {
        console.error("Camera access error:", error);
        statusText.textContent = "‚ùå Camera access denied or not available";
        statusText.style.color = "#dc3545";
        
        // Show toast and fallback to text input after a delay
        showToast("‚ùå Camera access denied or not available", "error");
        
        setTimeout(() => {
          closeQRScanner();
          const gameId = prompt("Enter Game ID to load game:");
          if (gameId) {
            loadGameById(gameId.trim().toUpperCase());
          }
        }, 2000);
      }
    }

    // Close QR Scanner
    function closeQRScanner() {
      const video = document.getElementById("qrScannerVideo");
      const statusText = document.getElementById("scannerStatus");
      const switchBtn = document.getElementById("switchCameraBtn");
      
      // Stop camera stream
      if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
      }

      // Clear scanning interval
      if (qrScanInterval) {
        clearInterval(qrScanInterval);
        qrScanInterval = null;
      }

      // Reset video
      video.srcObject = null;

      // Reset status text
      if (statusText) {
        statusText.textContent = "üì∑ Starting camera...";
        statusText.style.color = "#007bff";
      }

      // Hide switch camera button
      if (switchBtn) {
        switchBtn.style.display = "none";
      }

      // Reset scanner frame
      const scannerFrame = document.getElementById("scannerFrame");
      if (scannerFrame) {
        scannerFrame.style.borderColor = "#00ff00";
        scannerFrame.style.background = "rgba(0, 255, 0, 0.1)";
        scannerFrame.innerHTML = `
          <div style="
            color: #00ff00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: center;
            padding: 10px;
          ">
            üì± Position QR Code Here
          </div>
        `;
      }

      // Close modal
      document.getElementById("qrScannerModal").style.display = "none";
    }

    // Load game by ID - reads from gameData collection
    async function loadGameById(gameId, mode = currentScanMode) {
      if (!gameId) return;

      try {
        showToast("üì• Loading game from cloud...", "loading");

        // Load game data from gameData collection
        const gameDataSnap = await window.firestore.getDoc(
          window.firestore.doc(window.db, "gameData", gameId)
        );

        if (gameDataSnap.exists()) {
          const cloudData = gameDataSnap.data();
          localStorage.setItem("scoreData", JSON.stringify(cloudData.data));
          localStorage.setItem("gameId", gameId);
          
          // For edit mode, we already have the PIN set from validation
          // For view mode, we don't need the PIN
          if (mode === "edit" && isPINVerified) {
            console.log("Edit mode - PIN already validated and stored");
          } else {
            console.log("View mode - no PIN needed");
          }

          // Update point value and GST from cloud
          document.getElementById("pointValue").value =
            cloudData.data.pointValue || 1.0;
          document.getElementById("gstPercent").value =
            cloudData.data.gstPercent || 18.0;

          loadData();

          // Update Game ID display
          updateGameIdDisplay();

          // Show success toast based on mode
          if (mode === "edit" && isPINVerified) {
            isViewOnlyMode = false; // Enable editing
            showToast(`‚úÖ Game loaded in Edit Mode! ID: ${gameId}`, "success", 5000);
            // Optional: Show edit mode indicator in title
            document.title = "‚≠ê Rummy Score Master (Edit Mode)";
            setTimeout(() => (document.title = "‚≠ê Rummy Score Master"), 5000);
          } else {
            isViewOnlyMode = true; // Disable editing
            showToast(`üëÅÔ∏è Game loaded in View Only Mode! ID: ${gameId}`, "info", 5000);
            // Optional: Show view mode indicator in title
            document.title = "‚≠ê Rummy Score Master (View Only)";
            setTimeout(() => (document.title = "‚≠ê Rummy Score Master"), 5000);
          }

          // Apply view-only restrictions if needed
          if (isViewOnlyMode) {
            applyViewOnlyRestrictions();
          } else {
            removeViewOnlyRestrictions();
          }

          // Clear temporary game ID
          window.tempGameId = null;
        } else {
          showToast(
            "‚ùå Game ID not found. Please check and try again.",
            "error"
          );
        }
      } catch (error) {
        console.error("Load error:", error);
        showToast(
          "‚ùå Failed to load game. Check your internet connection.",
          "error"
        );
      }
    }

    // Function to apply view-only restrictions
    function applyViewOnlyRestrictions() {
      // Disable all score inputs
      const scoreInputs = document.querySelectorAll('input[id^="p"][id*="r"]');
      scoreInputs.forEach(input => {
        input.disabled = true;
        input.style.backgroundColor = "#f8f9fa";
        input.style.color = "#6c757d";
        input.style.cursor = "not-allowed";
        input.title = "View Only Mode - Editing disabled";
      });

      // Disable all player name inputs
      const nameInputs = document.querySelectorAll('input[id^="name"]');
      nameInputs.forEach(input => {
        input.disabled = true;
        input.style.backgroundColor = "#f8f9fa";
        input.style.color = "#6c757d";
        input.style.cursor = "not-allowed";
        input.title = "View Only Mode - Editing disabled";
      });

      // Disable Add Player button
      const addPlayerBtn = document.querySelector('.add-player-btn');
      if (addPlayerBtn) {
        addPlayerBtn.disabled = true;
        addPlayerBtn.style.backgroundColor = "#6c757d";
        addPlayerBtn.style.color = "#ffffff";
        addPlayerBtn.style.cursor = "not-allowed";
        addPlayerBtn.style.opacity = "0.6";
        addPlayerBtn.title = "View Only Mode - Cannot add players";
        addPlayerBtn.textContent = "üëÅÔ∏è View Only - Add Player Disabled";
      }

      // Disable Point Value and GST inputs
      const pointValueInput = document.getElementById("pointValue");
      const gstInput = document.getElementById("gstPercent");
      if (pointValueInput) {
        pointValueInput.disabled = true;
        pointValueInput.style.backgroundColor = "#f8f9fa";
        pointValueInput.style.color = "#6c757d";
        pointValueInput.style.cursor = "not-allowed";
        pointValueInput.title = "View Only Mode - Settings cannot be changed";
      }
      if (gstInput) {
        gstInput.disabled = true;
        gstInput.style.backgroundColor = "#f8f9fa";
        gstInput.style.color = "#6c757d";
        gstInput.style.cursor = "not-allowed";
        gstInput.title = "View Only Mode - Settings cannot be changed";
      }

      // Add visual indicator for view-only mode
      addViewOnlyIndicator();
    }

    // Function to remove view-only restrictions
    function removeViewOnlyRestrictions() {
      // Enable all score inputs
      const scoreInputs = document.querySelectorAll('input[id^="p"][id*="r"]');
      scoreInputs.forEach(input => {
        input.disabled = false;
        input.style.backgroundColor = "";
        input.style.color = "";
        input.style.cursor = "";
        input.title = "";
      });

      // Enable all player name inputs
      const nameInputs = document.querySelectorAll('input[id^="name"]');
      nameInputs.forEach(input => {
        input.disabled = false;
        input.style.backgroundColor = "";
        input.style.color = "";
        input.style.cursor = "";
        input.title = "";
      });

      // Enable Add Player button
      const addPlayerBtn = document.querySelector('.add-player-btn');
      if (addPlayerBtn) {
        addPlayerBtn.disabled = false;
        addPlayerBtn.style.backgroundColor = "";
        addPlayerBtn.style.color = "";
        addPlayerBtn.style.cursor = "";
        addPlayerBtn.style.opacity = "";
        addPlayerBtn.title = "";
        addPlayerBtn.textContent = "+ Add Player";
      }

      // Keep Point Value and GST inputs disabled if game is already started
      // (they should only be enabled for new games)
      const gameData = localStorage.getItem("scoreData");
      if (!gameData) {
        const pointValueInput = document.getElementById("pointValue");
        const gstInput = document.getElementById("gstPercent");
        if (pointValueInput) {
          pointValueInput.disabled = false;
          pointValueInput.style.backgroundColor = "";
          pointValueInput.style.color = "";
          pointValueInput.style.cursor = "";
          pointValueInput.title = "";
        }
        if (gstInput) {
          gstInput.disabled = false;
          gstInput.style.backgroundColor = "";
          gstInput.style.color = "";
          gstInput.style.cursor = "";
          gstInput.title = "";
        }
      }

      // Remove view-only indicator
      removeViewOnlyIndicator();
    }

    // Function to add visual indicator for view-only mode
    function addViewOnlyIndicator() {
      // Remove existing indicator if any
      removeViewOnlyIndicator();

      // Add indicator to the header
      const header = document.querySelector('h1');
      if (header) {
        const indicator = document.createElement('div');
        indicator.id = 'viewOnlyIndicator';
        indicator.innerHTML = `
          <div style="
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            margin: 10px auto;
            max-width: 300px;
            box-shadow: 0 2px 8px rgba(23, 162, 184, 0.3);
            animation: pulse 2s infinite;
          ">
            üëÅÔ∏è VIEW ONLY MODE - Editing Disabled
          </div>
        `;
        header.insertAdjacentElement('afterend', indicator);
      }
    }

    // Function to remove visual indicator
    function removeViewOnlyIndicator() {
      const indicator = document.getElementById('viewOnlyIndicator');
      if (indicator) {
        indicator.remove();
      }
    }

    // Auto-save to cloud (silent) - saves to gameData collection only
    async function autoSaveToCloud() {
      // Prevent auto-save in view-only mode
      if (isViewOnlyMode) {
        console.log("Auto-save blocked - View Only Mode");
        return;
      }

      const gameId = localStorage.getItem("gameId");
      if (!gameId || !window.db) return;

      const data = localStorage.getItem("scoreData");
      if (!data) return;

      try {
        // Save data to gameData collection (no need to check games collection)
        await window.firestore.setDoc(
          window.firestore.doc(window.db, "gameData", gameId),
          {
            data: JSON.parse(data),
            lastUpdated: window.firestore.serverTimestamp(),
            version: "1.0",
          }
        );

        console.log("Auto-save: Game data saved to gameData collection for gameId:", gameId);

        // Show sync indicator briefly
        document.title = "‚≠ê Rummy Score Master (Synced)";
        setTimeout(() => (document.title = "‚≠ê Rummy Score Master"), 2000);
      } catch (error) {
        console.error("Auto-save failed:", error);
      }
    }

    // Add modern toast notification system
    function showToast(message, type = "info", duration = 4000) {
      // Remove existing toast if any
      const existingToast = document.getElementById("toast");
      if (existingToast) {
        existingToast.remove();
      }

      // Create toast element
      const toast = document.createElement("div");
      toast.id = "toast";
      toast.textContent = message;

      // Base styles
      const baseStyles = {
        position: "fixed",
        top: "20px",
        right: "20px",
        padding: "12px 20px",
        borderRadius: "8px",
        color: "white",
        fontWeight: "500",
        fontSize: "14px",
        zIndex: "9999",
        boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
        maxWidth: "350px",
        wordWrap: "break-word",
        animation: "slideInRight 0.3s ease-out",
        fontFamily: "Arial, sans-serif",
      };

      // Type-specific styles
      const typeStyles = {
        loading: {
          backgroundColor: "#17a2b8",
          borderLeft: "4px solid #138496",
        },
        success: {
          backgroundColor: "#28a745",
          borderLeft: "4px solid #1e7e34",
        },
        error: {
          backgroundColor: "#dc3545",
          borderLeft: "4px solid #c82333",
        },
        info: {
          backgroundColor: "#007bff",
          borderLeft: "4px solid #0056b3",
        },
      };

      // Apply styles
      Object.assign(
        toast.style,
        baseStyles,
        typeStyles[type] || typeStyles.info
      );

      // Add loading spinner for loading type
      if (type === "loading") {
        const spinner = document.createElement("span");
        spinner.innerHTML = "‚è≥ ";
        spinner.style.marginRight = "8px";
        toast.insertBefore(spinner, toast.firstChild);
      }

      // Add to document
      document.body.appendChild(toast);

      // Auto remove (except for loading type)
      if (type !== "loading") {
        setTimeout(() => {
          if (toast.parentNode) {
            toast.style.animation = "slideOutRight 0.3s ease-in";
            setTimeout(() => toast.remove(), 300);
          }
        }, duration);
      }

      return toast;
    }

    // Helper function to hide loading toast
    function hideLoadingToast() {
      const toast = document.getElementById("toast");
      if (toast) {
        toast.style.animation = "slideOutRight 0.3s ease-in";
        setTimeout(() => toast.remove(), 300);
      }
    }

    // Add these functions to your existing script

    // Function to update Game ID display
    function updateGameIdDisplay() {
      const gameId = localStorage.getItem("gameId");
      const gamePin = localStorage.getItem("gamePin");
      const display = document.getElementById("gameIdDisplay");
      const qrContainer = document.getElementById("qrCodeContainer");
      const gameIdPinText = document.getElementById("gameIdPinText");
      // For copy function compatibility, keep a hidden input
      let input = document.getElementById("gameIdInput");
      if (!input) {
        input = document.createElement("input");
        input.type = "text";
        input.id = "gameIdInput";
        input.readOnly = true;
        input.style.display = "none";
        if (qrContainer && qrContainer.parentNode) {
          qrContainer.parentNode.appendChild(input);
        }
      }
      if (gameId) {
        // Set value for copy function
        input.value = gameId;
        display.style.display = "block";
        // Render QR code
        if (qrContainer) {
          qrContainer.innerHTML = "";
          new QRCode(qrContainer, {
            text: gameId,
            width: 90,
            height: 90,
            colorDark: "#1565c0",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.H,
          });
        }
        if (gameIdPinText) {
          gameIdPinText.textContent = `ID: ${gameId}   |   PIN: ${gamePin || ''}`;
        }
      } else {
        display.style.display = "none";
        if (qrContainer) qrContainer.innerHTML = "";
        if (gameIdPinText) gameIdPinText.textContent = "";
        input.value = "";
      }
    }

    // Function to copy Game ID with toast feedback
    function copyGameId() {
      const gameIdInput = document.getElementById("gameIdInput");
      const qrContainer = document.getElementById("qrCodeContainer");
      const gameId = gameIdInput.value;

      if (!gameId) {
        showToast("‚ùå No Game ID to copy!", "error");
        return;
      }

      // Copy to clipboard
      navigator.clipboard
        .writeText(gameId)
        .then(() => {
          // Show success toast
          showToast(`‚úÖ Game ID copied: ${gameId}`, "success", 3000);
          
          // Visual feedback on QR container
          qrContainer.classList.add("copied");
          setTimeout(() => {
            qrContainer.classList.remove("copied");
          }, 1000);
        })
        .catch(() => {
          // Fallback for older browsers
          gameIdInput.select();
          document.execCommand("copy");

          // Show success toast
          showToast(`‚úÖ Game ID copied: ${gameId}`, "success", 3000);
          
          // Visual feedback on QR container
          qrContainer.classList.add("copied");
          setTimeout(() => {
            qrContainer.classList.remove("copied");
          }, 1000);
        });
    }

    // Make Game ID input clickable for selection
    document.addEventListener("DOMContentLoaded", function () {
      const gameIdInput = document.getElementById("gameIdInput");
      if (gameIdInput) {
        gameIdInput.addEventListener("click", function () {
          this.select();
        });
      }

      // Handle scan mode radio button changes
      const modeRadios = document.querySelectorAll('input[name="scanMode"]');
      const pinContainer = document.getElementById("pinContainer");
      const pinInput = document.getElementById("pinInput");
      const pinMessage = document.getElementById("pinMessage");

      modeRadios.forEach(radio => {
        radio.addEventListener("change", function() {
          if (this.value === "edit") {
            // Show PIN container for edit mode
            pinContainer.style.display = "block";
            pinMessage.textContent = "";
            pinMessage.style.color = "#856404";
            pinInput.value = "";
            pinInput.focus();
          } else {
            // Hide PIN container for view mode
            pinContainer.style.display = "none";
            pinMessage.textContent = "üëÅÔ∏è View Only Mode - No PIN required";
            pinMessage.style.color = "#28a745";
          }
        });
      });

      // Handle PIN input for real-time validation
      if (pinInput) {
        pinInput.addEventListener("input", function() {
          // Only allow numeric input
          this.value = this.value.replace(/[^0-9]/g, '');
          
          // Clear any previous message
          pinMessage.textContent = "";
          pinMessage.style.color = "#856404";
          
          // If PIN is complete (4 digits), validate it
          if (this.value.length === 4) {
            setTimeout(() => validatePIN(this.value), 300); // Small delay for better UX
          }
        });

        // Handle Enter key on PIN input
        pinInput.addEventListener("keypress", function(e) {
          if (e.key === "Enter" && this.value.length === 4) {
            validatePIN(this.value);
          }
        });
      }

      // Close QR scanner modal when clicking outside
      const qrModal = document.getElementById("qrScannerModal");
      if (qrModal) {
        qrModal.addEventListener("click", function (event) {
          if (event.target === qrModal) {
            closeQRScanner();
          }
        });
      }

      // Close QR scanner on Escape key
      document.addEventListener("keydown", function (event) {
        if (event.key === "Escape" && qrModal.style.display === "block") {
          closeQRScanner();
        }
      });
    });
    window.onload = function () {
      loadData();
      updateGameIdDisplay();
    };

    // Add close game function that clears everything
    async function closeGame() {
      // First, save any unsaved data to cloud before clearing
      await saveCurrentDataToCloud();

      // Clear ALL localStorage data
      localStorage.removeItem("scoreData");
      localStorage.removeItem("gameId");
      localStorage.removeItem("gamePin");
      localStorage.clear(); // Remove any other related data

      // Reset view-only mode
      isViewOnlyMode = false;
      removeViewOnlyIndicator();

      // Clear the game display
      document.getElementById("scoreTableContainer").innerHTML = "";
      document.getElementById("leaderboard").innerHTML = "";

      // Clear chart
      const canvas = document.getElementById("scoreChart");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (chart) {
        chart.destroy();
        chart = null;
      }

      // Reset inputs to defaults
      document.getElementById("pointValue").value = "1.00";
      document.getElementById("gstPercent").value = "18.00";

      // Hide Game ID display
      const gameIdDisplay = document.getElementById("gameIdDisplay");
      if (gameIdDisplay) {
        gameIdDisplay.style.display = "none";
      }

      // Clear Game ID input
      const gameIdInput = document.getElementById("gameIdInput");
      if (gameIdInput) {
        gameIdInput.value = "";
      }

      // Re-enable game settings
      enableGameSettings();

      // Reset page title
      document.title = "‚≠ê Rummy Score Master";

      // No modal needed - user can see the fresh state immediately
    }

    async function saveCurrentDataToCloud() {
      // Prevent saving in view-only mode
      if (isViewOnlyMode) {
        console.log("Cloud save blocked - View Only Mode");
        return;
      }

      const gameId = localStorage.getItem("gameId");
      const data = localStorage.getItem("scoreData");

      // Only save if we have both gameId and data, and Firebase is ready
      if (!gameId || !data || !window.db) {
        return; // Skip cloud save if no data or Firebase not ready
      }

      try {
        // Parse existing data
        const gameData = JSON.parse(data);

        // Save data to gameData collection only
        const gameDataRef = window.firestore.doc(window.db, "gameData", gameId);
        
        await window.firestore.setDoc(gameDataRef, {
          data: gameData,
          lastUpdated: window.firestore.serverTimestamp(),
          version: "1.0",
        });

        console.log("Data saved to gameData collection for gameId:", gameId);
      } catch (error) {
        console.error("Failed to save to cloud:", error);
        // Don't show error to user, just log it
      }
    }

    // Update confirmCloseGame message
    function confirmCloseGame() {
      showModal(
        "üóëÔ∏è Clear Local Game Data",
        "This will permanently delete all game data from your browser's local storage and reset the app. Any data saved to the cloud will remain safe. Continue?",
        () => {
          closeGame();
        }
      );
    }
  </script>
</body>
</html>