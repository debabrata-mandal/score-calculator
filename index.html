<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>⭐ Rummy Score Master</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Cache Control Headers -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  
  <!-- Version for cache busting - Update this with each deployment -->
  <meta name="app-version" content="v2.2.1" />
  
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="assets/css/styles.css">
  
  <!-- Register Service Worker for cache management -->
  <script src="assets/js/sw-register.js"></script>
  <!-- Styles moved to assets/css/styles.css -->
</head>

<body>
  <div class="container">
    <div style="display: flex; align-items: center; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 10px;">
      <h1 style="margin: 0;">⭐ Rummy Score Master</h1>
      
      <!-- Action buttons container -->
      <div id="titleActionButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
        <!-- Close Game button (shown when game is active) -->
        <button id="closeGameIconBtn" onclick="confirmCloseGame()" style="
          background: linear-gradient(135deg, #dc3545, #c82333);
          color: white;
          border: none;
          border-radius: 8px;
          width: 36px;
          height: 36px;
          cursor: pointer;
          font-size: 14px;
          font-weight: 700;
          display: none;
          align-items: center;
          justify-content: center;
          transition: all 0.3s ease;
          box-shadow: 0 2px 6px rgba(220, 53, 69, 0.3);
          font-family: Arial, sans-serif;
          line-height: 1;
        " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(220, 53, 69, 0.4)'" 
           onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 6px rgba(220, 53, 69, 0.3)'"
           title="End current game and return to setup">
          ×
        </button>
      </div>
    </div>

    <!-- Move Game ID Display Section here - right after title -->
    <!-- Update the Game ID Display Section to be cleaner -->
    <div id="gameIdDisplay" style="
          text-align: center;
          margin: 15px 0;
          padding: 12px;
          background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
          border-radius: 8px;
          border: 2px solid #e1bee7;
          display: none;
        ">
      <div style="
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
          ">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 6px;">
          <div id="qrCodeContainer" style="
                background: white;
                border: 2px solid #1565c0;
                border-radius: 6px;
                padding: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                min-width: 120px;
                min-height: 50px;
                cursor: pointer;
                transition: all 0.3s ease;
              " onclick="copyGameId()" title="Click to copy Game ID"></div>
          <div id="gameIdPinText" style="font-size: 15px; color: #333; margin-top: 2px;"></div>
        </div>
      </div>
      <!-- QRCode.js CDN -->
      <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    </div>

    <!-- QR Scanner Modal -->
    <div id="qrScannerModal" class="modal">
      <div class="modal-content" style="max-width: 500px; padding: 15px;">
        <h3 style="margin: 0 0 15px 0; text-align: center;">📱 Scan QR Code</h3>
        
        <!-- Mode Selection Radio Buttons -->
        <div style="
          display: flex;
          justify-content: center;
          gap: 20px;
          margin: 15px 0;
          padding: 10px;
          background: linear-gradient(135deg, #f8f9fa, #e9ecef);
          border-radius: 8px;
          border: 1px solid #dee2e6;
        ">
          <label style="
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
          ">
            <input type="radio" name="scanMode" value="view" checked style="
              margin: 0;
              transform: scale(1.1);
            ">
            <span>👁️ View Only</span>
          </label>
          <label style="
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
          ">
            <input type="radio" name="scanMode" value="edit" style="
              margin: 0;
              transform: scale(1.1);
            ">
            <span>✏️ Edit Mode</span>
          </label>
        </div>
        
        <!-- PIN Input Container (initially hidden) -->
        <div id="pinContainer" style="
          display: none;
          margin: 15px 0;
          padding: 15px;
          background: linear-gradient(135deg, #fff3cd, #ffeaa7);
          border: 2px solid #ffc107;
          border-radius: 8px;
          text-align: center;
        ">
          <label for="pinInput" style="
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #856404;
            font-size: 14px;
          ">
            🔐 Enter PIN for Edit Access:
          </label>
          <input type="password" id="pinInput" maxlength="4" placeholder="4-digit PIN" style="
            width: 120px;
            padding: 10px 8px;
            text-align: center;
            border: 2px solid #ffc107;
            border-radius: 6px;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 3px;
            background-color: white;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
          ">
          <div id="pinMessage" style="
            margin-top: 10px;
            font-size: 13px;
            font-weight: 500;
            min-height: 18px;
            transition: all 0.3s ease;
          "></div>
        </div>
        
        <div id="qrScannerContainer" style="
          position: relative;
          width: 100%;
          max-width: 400px;
          margin: 0 auto;
          background: #000;
          border-radius: 8px;
          overflow: hidden;
        ">
          <video id="qrScannerVideo" style="
            width: 100%;
            height: 300px;
            object-fit: cover;
            display: block;
          "></video>
          <div id="scannerOverlay" style="
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
          ">
            <div id="scannerFrame" style="
              width: 250px;
              height: 250px;
              border: 3px solid #00ff00;
              border-radius: 12px;
              background: rgba(0, 255, 0, 0.1);
              animation: scannerPulse 2s infinite;
              position: relative;
              display: flex;
              align-items: center;
              justify-content: center;
            ">
              <div style="
                color: #00ff00;
                font-size: 16px;
                font-weight: bold;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                text-align: center;
                padding: 10px;
              ">
                📱 Position QR Code Here
              </div>
            </div>
          </div>
          <canvas id="qrScannerCanvas" style="display: none;"></canvas>
        </div>
        <div style="margin-top: 15px; text-align: center;">
          <p id="scannerStatus" style="color: #007bff; font-size: 14px; margin: 10px 0; font-weight: 500;">
            📷 Starting camera...
          </p>
          <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
            <button id="switchCameraBtn" onclick="switchCamera()" style="
              background-color: #17a2b8;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 8px 16px;
              cursor: pointer;
              font-size: 14px;
              display: none;
            ">🔄 Switch Camera</button>
            <button onclick="manualEntry()" style="
              background-color: #ffc107;
              color: #212529;
              border: none;
              border-radius: 4px;
              padding: 8px 16px;
              cursor: pointer;
              font-size: 14px;
            ">⌨️ Manual Entry</button>
            <button onclick="closeQRScanner()" style="
              background-color: #6c757d;
              color: white;
              border: none;
              border-radius: 4px;
              padding: 8px 16px;
              cursor: pointer;
              font-size: 14px;
            ">❌ Cancel</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Setup Section -->
    <div class="controls" style="margin-top: 10px">
      <!-- Load Game Section -->
      <div style="
        background: linear-gradient(135deg, #e3f2fd, #f3e5f5);
        padding: 15px;
        border-radius: 8px;
        border: 2px solid #e1bee7;
        margin-bottom: 15px;
      ">
        <h3 style="
          margin: 0 0 12px 0;
          font-size: 16px;
          color: #4a148c;
          text-align: center;
        ">📱 Load Existing Game</h3>
        
        <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; margin-bottom: 12px">
          <button onclick="loadFromCloud()" style="
            background: linear-gradient(135deg, #17a2b8, #20c997);
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 3px 8px rgba(23, 162, 184, 0.3);
            transition: all 0.3s ease;
          " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(23, 162, 184, 0.4)'" 
             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(23, 162, 184, 0.3)'">
            📱 Scan QR / Load Game
          </button>
        </div>
        
        <!-- Load Game Helper Text -->
        <div style="margin-top: 12px; padding: 12px; background-color: #e8f4f8; border-radius: 6px; border-left: 4px solid #17a2b8;">
          <h4 style="margin: 0 0 8px 0; color: #0c5460; font-size: 14px;">💡 Load Game Guide:</h4>
          <ul style="margin: 0; padding-left: 18px; font-size: 12px; color: #0c5460; line-height: 1.4;">
            <li><strong>Scan QR:</strong> Use your phone camera to scan QR code from another device</li>
            <li><strong>Manual Entry:</strong> Enter Game ID directly if you have it</li>
            <li><strong>View Mode:</strong> Join as spectator to watch the game</li>
            <li><strong>Edit Mode:</strong> Join with PIN to participate and make changes</li>
          </ul>
        </div>
      </div>

      <!-- Game Setup Group -->
      <div style="
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        padding: 15px;
        border-radius: 8px;
        border: 2px solid #dee2e6;
        margin-bottom: 10px;
      ">
        <h3 style="
          margin: 0 0 12px 0;
          font-size: 16px;
          color: #495057;
          text-align: center;
        ">🎮 Game Setup</h3>
        
        <!-- Financial Settings -->
        <div style="display: flex; align-items: center; gap: 20px; flex-wrap: wrap; justify-content: center; margin-bottom: 12px">
          <div style="display: flex; align-items: center; gap: 8px; min-width: 180px">
            <label for="pointValue" style="font-weight: 600; color: #495057; white-space: nowrap; width: 100px; text-align: right">Point Value:</label>
            <span style="font-weight: 600; color: #495057; width: 12px; text-align: center">₹</span>
            <input type="number" id="pointValue" min="0" step="0.01" value="0.15" style="width: 80px; padding: 6px; border: 2px solid #ced4da; border-radius: 4px; text-align: center; font-weight: 600"
              onchange="saveData();" />
          </div>
          
          <div style="display: flex; align-items: center; gap: 8px; min-width: 180px">
            <label for="gstPercent" style="font-weight: 600; color: #495057; white-space: nowrap; width: 100px; text-align: right">GST Value:</label>
            <span style="font-weight: 600; color: #495057; width: 12px; text-align: center">%</span>
            <input type="number" id="gstPercent" min="0" max="100" step="0.01" value="25.00" style="width: 80px; padding: 6px; border: 2px solid #ced4da; border-radius: 4px; text-align: center; font-weight: 600"
              onchange="saveData();" />
          </div>
        </div>
        
        <!-- Start Game Button -->
        <div style="text-align: center">
          <button class="start-play-button" onclick="startNewGame()" style="
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 6px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 3px 8px rgba(40, 167, 69, 0.3);
            transition: all 0.3s ease;
          " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(40, 167, 69, 0.4)'" 
             onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(40, 167, 69, 0.3)'">
            🎮 Start New Game
          </button>
        </div>
        
        <!-- Game Setup Helper Text -->
        <div id="gameSetupInfo" style="margin-top: 15px; padding: 12px; background-color: #e8f5e8; border-radius: 6px; border-left: 4px solid #28a745;">
          <h4 style="margin: 0 0 8px 0; color: #155724; font-size: 14px;">💡 Game Setup Guide:</h4>
          <ul style="margin: 0; padding-left: 18px; font-size: 12px; color: #155724; line-height: 1.4;">
            <li><strong>Point Value:</strong> Amount each point is worth</li>
            <li><strong>GST Value:</strong> Tax percentage on winnings</li>
            <li><strong>Start Game:</strong> Creates a new game with QR code for sharing</li>
          </ul>
        </div>
      </div>
    </div>

    <div id="scoreTableContainer"></div>
    <div class="leaderboard" id="leaderboard"></div>
    <div class="chart-container">
      <canvas id="scoreChart"></canvas>
    </div>
  </div>
  <!-- Custom Confirmation Modal -->
  <div id="confirmModal" class="modal">
    <div class="modal-content">
      <h3 id="modalTitle">⚠️ Confirm Action</h3>
      <p id="modalMessage">Are you sure you want to proceed?</p>
      <div class="modal-buttons">
        <button class="modal-button confirm" onclick="confirmAction()">
          Yes, Proceed
        </button>
        <button class="modal-button cancel" onclick="closeModal()">
          Cancel
        </button>
      </div>
    </div>
  </div>
  <!-- Add Firebase SDK before your existing script -->
  <script type="module" src="assets/js/firebase-init.js"></script>
  <!-- QR Code Scanner Library -->
  <script src="https://unpkg.com/jsqr@1.4.0/dist/jsQR.js"></script>
  <!-- App logic -->
  <script src="assets/js/app.js"></script>
  <!-- Legacy inline script removed (moved to assets/js/app.js) -->
  <script>
    // Inline logic moved to assets/js/app.js
    const CURRENT_VERSION = document.querySelector('meta[name="app-version"]').getAttribute('content'); // Read from meta tag
    
    // Check for updates every 5 minutes
    let updateCheckInterval = null;
    
    function startUpdateChecker() {
      // Clear any existing interval
      if (updateCheckInterval) {
        clearInterval(updateCheckInterval);
      }
      
      // Check for updates every 5 minutes (300000 ms)
      updateCheckInterval = setInterval(() => {
        checkForUpdates();
      }, 300000);
      
      // Also check immediately on page load (after 10 seconds)
      setTimeout(() => {
        checkForUpdates();
      }, 10000);
    }
    
    async function checkForUpdates() {
      try {
        // Fetch the current page with cache-busting parameter
        const response = await fetch(window.location.href + '?_cb=' + Date.now(), {
          method: 'HEAD', // Use HEAD to just check headers, not download full content
          cache: 'no-cache',
          headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache'
          }
        });
        
        if (response.ok) {
          // Try to get version from server (this is a simple approach)
          // In a real deployment, you might have a separate endpoint for version checking
          const fullResponse = await fetch(window.location.href + '?_cb=' + Date.now(), {
            cache: 'no-cache'
          });
          
          const htmlContent = await fullResponse.text();
          const versionMatch = htmlContent.match(/name="app-version"\s+content="([^"]+)"/);
          
          if (versionMatch) {
            const serverVersion = versionMatch[1];
            
            if (serverVersion !== CURRENT_VERSION) {
              console.log(`Update detected: ${CURRENT_VERSION} -> ${serverVersion}`);
              showUpdateNotification(serverVersion);
            }
          }
        }
      } catch (error) {
        console.log('Update check failed (this is normal if offline):', error);
        // Silently fail - don't bother users with network errors
      }
    }
    
    function showUpdateNotification(newVersion) {
      // Stop checking for more updates
      if (updateCheckInterval) {
        clearInterval(updateCheckInterval);
        updateCheckInterval = null;
      }
      
      // Show a prominent update notification
      const updateBanner = document.createElement('div');
      updateBanner.id = 'updateBanner';
      updateBanner.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, #ff6b35, #f7931e);
        color: white;
        padding: 12px 20px;
        text-align: center;
        font-weight: 600;
        font-size: 14px;
        z-index: 10000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        animation: slideDown 0.3s ease-out;
      `;
      
      updateBanner.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; gap: 15px; flex-wrap: wrap;">
          <span>🚀 New version available (${newVersion})! Click to update.</span>
          <button onclick="forceReload()" style="
            background: white;
            color: #ff6b35;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-size: 12px;
          ">
            Update Now
          </button>
          <button onclick="dismissUpdate()" style="
            background: transparent;
            color: white;
            border: 1px solid white;
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-size: 12px;
          ">
            Later
          </button>
        </div>
      `;
      
      // Add CSS animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideDown {
          from { transform: translateY(-100%); }
          to { transform: translateY(0); }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(updateBanner);
      
      // Auto-update after 30 seconds if user doesn't respond
      setTimeout(() => {
        if (document.getElementById('updateBanner')) {
          forceReload();
        }
      }, 30000);
    }
    
    function forceReload() {
      // Save current game state before reloading
      if (typeof saveCurrentDataToCloud === 'function' && !isViewOnlyMode) {
        saveCurrentDataToCloud().finally(() => {
          performReload();
        });
      } else {
        performReload();
      }
    }
    
    function performReload() {
      // Add cache-busting parameters and reload
      const url = new URL(window.location);
      url.searchParams.set('_cb', Date.now());
      url.searchParams.set('_v', Date.now());
      
      // Show loading state
      showToast("🔄 Updating app to latest version...", "loading", 2000);
      
      setTimeout(() => {
        window.location.href = url.toString();
      }, 1000);
    }
    
    function dismissUpdate() {
      const banner = document.getElementById('updateBanner');
      if (banner) {
        banner.style.animation = 'slideUp 0.3s ease-in';
        setTimeout(() => banner.remove(), 300);
      }
      
      // Restart update checker in 15 minutes
      setTimeout(() => {
        startUpdateChecker();
      }, 900000); // 15 minutes
    }

    let chart;
    let pendingAction = null;

    // Real-time listener variables
    let realtimeListener = null;
    let lastKnownUpdateTime = null;

    function showModal(title, message, action) {
      document.getElementById("modalTitle").textContent = title;
      document.getElementById("modalMessage").textContent = message;
      document.getElementById("confirmModal").style.display = "block";
      pendingAction = action;
    }

    function closeModal() {
      document.getElementById("confirmModal").style.display = "none";
      pendingAction = null;
    }

    function confirmAction() {
      if (pendingAction) {
        pendingAction();
      }
      closeModal();
    }

    function saveData() {
      // Prevent saving in view-only mode
      if (isViewOnlyMode) {
        console.log("Save blocked - View Only Mode");
        return;
      }

      // Get number of players from the actual table instead of input
      const playerRows =
        document.querySelectorAll('input[id^="name"]').length;
      const pointValue =
        parseFloat(document.getElementById("pointValue").value) || 0.15;
      const gstPercent =
        parseFloat(document.getElementById("gstPercent").value) || 25.0;

      const data = {
        numPlayers: playerRows,
        pointValue,
        gstPercent,
        players: [],
      };

      for (let i = 1; i <= playerRows; i++) {
        const nameInput = document.getElementById(`name${i}`);
        if (nameInput) {
          const name = nameInput.value.trim();
          const scores = [];
          for (let j = 1; j <= 10; j++) {
            const scoreInput = document.getElementById(`p${i}r${j}`);
            const val = scoreInput ? parseInt(scoreInput.value) : -1;
            scores.push(isNaN(val) ? -1 : val);
          }
          // Get the random number from the data attribute
          const randomNumber = parseInt(nameInput.dataset.randomNumber) || null;
          data.players.push({ name, scores, randomNumber });
        }
      }
      localStorage.setItem("scoreData", JSON.stringify(data));

      // Add auto-save to cloud
      autoSaveToCloud();
    }

    // Add function to disable game settings after start
    function disableGameSettingsAfterStart() {
      // Hide Load Game and Game Setup sections entirely
      const loadGameSection = document.querySelector('.controls > div:first-child');
      const gameSetupSection = document.querySelector('.controls > div:nth-child(2)');
      
      if (loadGameSection) {
        loadGameSection.style.display = "none";
      }
      
      if (gameSetupSection) {
        gameSetupSection.style.display = "none";
      }

      // Show Close Game icon button
      const closeGameIconBtn = document.getElementById("closeGameIconBtn");
      if (closeGameIconBtn) {
        closeGameIconBtn.style.display = "flex";
      }
    }

    // Add function to enable game settings (for new games)
    function enableGameSettings() {
      // Show Load Game and Game Setup sections
      const loadGameSection = document.querySelector('.controls > div:first-child');
      const gameSetupSection = document.querySelector('.controls > div:nth-child(2)');
      
      if (loadGameSection) {
        loadGameSection.style.display = "block";
      }
      
      if (gameSetupSection) {
        gameSetupSection.style.display = "block";
      }

      // Hide Close Game icon button
      const closeGameIconBtn = document.getElementById("closeGameIconBtn");
      if (closeGameIconBtn) {
        closeGameIconBtn.style.display = "none";
      }
    }

    function loadData() {
      const saved = localStorage.getItem("scoreData");
      if (!saved) {
        // No saved data - enable settings and reset view-only mode
        isViewOnlyMode = false;
        localStorage.removeItem("gameMode"); // Clear any stored mode
        removeViewOnlyIndicator();
        enableGameSettings();
        return;
      }

      const data = JSON.parse(saved);

      document.getElementById("pointValue").value = data.pointValue || 0.15;
      document.getElementById("gstPercent").value = data.gstPercent || 25.0;

      generateTable(data, false); // Don't save when loading existing data

      // Update Game ID display
      updateGameIdDisplay();

      // Check if we should be in view-only mode (from localStorage)
      const storedMode = localStorage.getItem("gameMode");
      if (storedMode === "view") {
        isViewOnlyMode = true;
        console.log("Page refresh: Restoring View Only mode from localStorage");
      } else if (storedMode === "edit") {
        isViewOnlyMode = false;
        console.log("Page refresh: Restoring Edit mode from localStorage");
      } else {
        // No stored mode, default to edit mode for existing games
        isViewOnlyMode = false;
        localStorage.setItem("gameMode", "edit");
        console.log("Page refresh: No stored mode, defaulting to Edit mode");
      }

      // Apply appropriate restrictions
      if (isViewOnlyMode) {
        applyViewOnlyRestrictions();
        // Start real-time listener for view-only mode on page refresh
        const gameId = localStorage.getItem("gameId");
        if (gameId) {
          console.log("Starting real-time listener for view-only mode on page refresh");
          startRealtimeListener(gameId);
        }
      } else {
        removeViewOnlyRestrictions();
        // Stop any existing real-time listener for edit mode
        stopRealtimeListener();
      }

      // Disable settings since game is already started
      disableGameSettingsAfterStart();
      
      // Update WhatsApp button visibility
      updateWhatsAppButtons();
    }

    function startNewGame() {
      // Check if Start Play button is already disabled
      const startButton = document.querySelector(".start-play-button");
      if (startButton && startButton.disabled) {
        return; // Prevent action if button is disabled
      }

      // Just start the game directly
      localStorage.removeItem("scoreData");
      localStorage.removeItem("gameId");
      localStorage.removeItem("gamePin");
      localStorage.removeItem("gameMode"); // Clear any previous mode

      // Reset view-only mode for new games
      isViewOnlyMode = false;
      localStorage.setItem("gameMode", "edit"); // Store edit mode for new games
      removeViewOnlyIndicator();

      // Stop any existing real-time listener since we're starting fresh
      stopRealtimeListener();

      // Generate new Game ID
      const gameId = Math.random().toString(36).substr(2, 9).toUpperCase();
      localStorage.setItem("gameId", gameId);

      // Generate a random 4-digit PIN (string, leading zeros allowed), never '0000'
      let pin;
      do {
        pin = ("000" + Math.floor(Math.random() * 10000)).slice(-4);
      } while (pin === "0000");
      localStorage.setItem("gamePin", pin);
      console.log("Generated PIN for new game:", pin);

      // Initialize game with 2 players WITHOUT random numbers (since only 2 players)
      const initialGameData = {
        numPlayers: 2,
        pointValue: parseFloat(document.getElementById("pointValue").value) || 0.15,
        gstPercent: parseFloat(document.getElementById("gstPercent").value) || 25.0,
        players: [
          {
            name: "Player 1",
            scores: Array(10).fill(-1),
            randomNumber: null // No random number for initial 2 players
          },
          {
            name: "Player 2",
            scores: Array(10).fill(-1),
            randomNumber: null // No random number for initial 2 players
          }
        ]
      };
      
      // Save to localStorage
      localStorage.setItem("scoreData", JSON.stringify(initialGameData));
      
      console.log(`Game initialized with 2 players (no random numbers assigned)`);

      generateTable(initialGameData, true); // Should save since this is creating new game
      updateGameIdDisplay();
      disableGameSettingsAfterStart();

      // Save initial game state to cloud with PIN only (no device info)
      saveInitialGameStateToCloud(pin);
      
      // Show WhatsApp buttons for new game
      updateWhatsAppButtons();
    }

    // ...existing code...

    // Add helper function to save initial game state to cloud with separate collections
    async function saveInitialGameStateToCloud(pin) {
      const gameId = localStorage.getItem("gameId");
      const data = localStorage.getItem("scoreData");

      // Only save if we have gameId and Firebase is ready
      if (!gameId || !window.db) {
        return; // Skip cloud save if no gameId or Firebase not ready
      }

      try {
        // Parse existing data or create empty structure
        const gameData = data
          ? JSON.parse(data)
          : {
            numPlayers: 2,
            pointValue:
              parseFloat(document.getElementById("pointValue").value) ||
              1.0,
            gstPercent:
              parseFloat(document.getElementById("gstPercent").value) ||
              18.0,
            players: [],
          };

        // Save authentication data to 'games' collection (ID + PIN only)
        await window.firestore.setDoc(
          window.firestore.doc(window.db, "games", gameId),
          {
            gameId: gameId,
            pin: pin || localStorage.getItem("gamePin") || "0000", // Fallback to "0000" if PIN is somehow missing
            createdAt: window.firestore.serverTimestamp(),
            version: "1.0",
          }
        );

        // Save game data to 'gameData' collection (scores and settings)
        await window.firestore.setDoc(
          window.firestore.doc(window.db, "gameData", gameId),
          {
            data: gameData,
            lastUpdated: window.firestore.serverTimestamp(),
            version: "1.0",
          }
        );

        console.log("Initial game state saved - Games collection (auth):", gameId, "PIN:", pin || localStorage.getItem("gamePin"));
        console.log("Initial game state saved - GameData collection (data):", gameId);
      } catch (error) {
        console.error("Failed to save initial game state to cloud:", error);
        // Don't show error to user, just log it
      }
    }

    // Add helper function to generate random number for new players
    function generateRandomNumber(existingNumbers = []) {
      let randomNum;
      do {
        randomNum = Math.floor(Math.random() * 89) + 11; // Generates 11-99
      } while (existingNumbers.includes(randomNum));
      return randomNum;
    }

    // Add helper function to get all existing random numbers
    function getExistingRandomNumbers(savedData = null) {
      const existingNumbers = [];
      
      if (savedData && savedData.players) {
        savedData.players.forEach(player => {
          if (player.randomNumber) {
            existingNumbers.push(player.randomNumber);
          }
        });
      }
      
      return existingNumbers;
    }

    // Add helper function to sort players by random number
    function sortPlayersByRandomNumber(players) {
      return players.sort((a, b) => {
        // If both players don't have random numbers, keep original order
        if (!a.randomNumber && !b.randomNumber) return 0;
        // Players without random numbers go to the end
        if (!a.randomNumber) return 1;
        if (!b.randomNumber) return -1;
        // Sort by random number (lowest to highest)
        return a.randomNumber - b.randomNumber;
      });
    }

    function addPlayer() {
      // Prevent adding players in view-only mode
      if (isViewOnlyMode) {
        showToast("❌ Cannot add players in View Only mode", "error");
        return;
      }

      // Get current number of players from existing table
      const currentPlayers =
        document.querySelectorAll('input[id^="name"]').length;

      if (currentPlayers >= 15) {
        showModal(
          "⚠️ Maximum Players Reached",
          "Maximum 15 players allowed!",
          null
        );
        return;
      }

      // Save current data first
      saveData();

      // Get existing data and add one more player
      const saved = localStorage.getItem("scoreData");
      let savedData = null;
      let newPlayerName = `Player ${currentPlayers + 1}`;

      if (saved) {
        savedData = JSON.parse(saved);
        
        // Check if we need to assign random numbers (only when going from 2 to 3+ players)
        const newPlayerCount = currentPlayers + 1;
        let newRandomNumber = null;
        
        if (newPlayerCount > 2) {
          // First time adding a 3rd player - assign random numbers to all players
          if (currentPlayers === 2) {
            // Assign random numbers to existing 2 players first
            const existingNumbers = [];
            savedData.players.forEach(player => {
              if (!player.randomNumber) {
                player.randomNumber = generateRandomNumber(existingNumbers);
                existingNumbers.push(player.randomNumber);
              }
            });
            console.log("Assigned random numbers to existing 2 players when adding 3rd player");
          }
          
          // Get existing random numbers to avoid duplicates
          const existingNumbers = getExistingRandomNumbers(savedData);
          
          // Generate random number for the new player
          newRandomNumber = generateRandomNumber(existingNumbers);
          
          console.log(`New player added with random number: ${newRandomNumber}`);
        } else {
          console.log(`New player added without random number (only ${newPlayerCount} players)`);
        }
        
        // Add new player
        const newPlayer = {
          name: newPlayerName,
          scores: Array(10).fill(-1),
          randomNumber: newRandomNumber
        };
        
        savedData.players.push(newPlayer);
        savedData.numPlayers = savedData.players.length;
        
        // Sort players by random number only if we have random numbers
        if (newPlayerCount > 2) {
          savedData.players = sortPlayersByRandomNumber(savedData.players);
          // Find the new player's position after sorting
          const newPlayerIndex = savedData.players.findIndex(p => p.name === newPlayerName);
          if (newPlayerIndex !== -1) {
            // Store which row should be animated (1-based index)
            window.newPlayerRowIndex = newPlayerIndex + 1;
          }
        } else {
          // For 2 or fewer players, the new player is always at the end
          window.newPlayerRowIndex = savedData.players.length;
        }
      } else {
        // If no saved data, create new structure
        savedData = {
          numPlayers: currentPlayers + 1,
          pointValue: parseFloat(document.getElementById("pointValue").value) || 0.15,
          gstPercent: parseFloat(document.getElementById("gstPercent").value) || 25.0,
          players: []
        };
        
        // Add new player without random number (since it's likely the first or second player)
        savedData.players.push({
          name: newPlayerName,
          scores: Array(10).fill(-1),
          randomNumber: null
        });
        
        // Store which row should be animated
        window.newPlayerRowIndex = savedData.players.length;
      }

      // Update localStorage
      localStorage.setItem("scoreData", JSON.stringify(savedData));

      // Regenerate table with existing data preserved + new player (should save since this is user action)
      generateTable(savedData, true);
      
      // Apply animation to the new player row after table generation
      setTimeout(() => {
        animateNewPlayerRow();
      }, 100);
    }

    // Function to animate the newly added player row
    function animateNewPlayerRow() {
      if (window.newPlayerRowIndex) {
        // Find the table row for the new player (nth-child is 1-based, +1 for header row)
        const tableBody = document.querySelector('#scoreTableContainer tbody');
        if (tableBody) {
          const newRow = tableBody.querySelector(`tr:nth-child(${window.newPlayerRowIndex})`);
          if (newRow) {
            // Add the animation class
            newRow.classList.add('new-player-row');
            
            // Scroll the new row into view smoothly
            newRow.scrollIntoView({ 
              behavior: 'smooth', 
              block: 'center',
              inline: 'nearest'
            });
            
            // Remove the animation class after animation completes
            setTimeout(() => {
              newRow.classList.remove('new-player-row');
            }, 2000);
            
            // Focus on the name input of the new player
            const nameInput = newRow.querySelector('input[type="text"]');
            if (nameInput) {
              setTimeout(() => {
                nameInput.focus();
                nameInput.select(); // Select all text for easy editing
              }, 500);
            }
          }
        }
        
        // Clear the stored index
        window.newPlayerRowIndex = null;
      }
    }

    function deletePlayer(playerIndex) {
      // Prevent deleting players in view-only mode
      if (isViewOnlyMode) {
        showToast("❌ Cannot delete players in View Only mode", "error");
        return;
      }

      // Get current number of players
      const currentPlayers = document.querySelectorAll('input[id^="name"]').length;

      if (currentPlayers <= 2) {
        showModal(
          "⚠️ Minimum Players Required",
          "At least 2 players are required to play the game!",
          null
        );
        return;
      }

      // Get player name for confirmation
      const nameInput = document.getElementById(`name${playerIndex}`);
      const playerName = nameInput ? nameInput.value.trim() || `Player ${playerIndex}` : `Player ${playerIndex}`;

      // Show confirmation modal
      showModal(
        "🗑️ Delete Player",
        `Are you sure you want to delete "${playerName}"? This action cannot be undone.`,
        () => {
          performDeletePlayer(playerIndex);
        }
      );
    }

    function performDeletePlayer(playerIndex) {
      // Save current data first
      saveData();

      // Get existing data
      const saved = localStorage.getItem("scoreData");
      if (!saved) return;

      const savedData = JSON.parse(saved);
      
      // Remove the player from the data (playerIndex is 1-based, but we need to find by current display order)
      if (savedData.players && savedData.players.length >= playerIndex) {
        // Get the current sorted order only if we have more than 2 players
        if (savedData.players.length > 2) {
          const sortedPlayers = sortPlayersByRandomNumber(savedData.players);
          const playerToDelete = sortedPlayers[playerIndex - 1];
          
          // Find and remove this player from the original array
          const originalIndex = savedData.players.findIndex(p => 
            (p.randomNumber && p.randomNumber === playerToDelete.randomNumber) || 
            (p.name === playerToDelete.name && p.scores.join(',') === playerToDelete.scores.join(','))
          );
          
          if (originalIndex !== -1) {
            savedData.players.splice(originalIndex, 1);
          }
        } else {
          // For 2 players or less, simple removal by index
          savedData.players.splice(playerIndex - 1, 1);
        }
        
        savedData.numPlayers = savedData.players.length;
        
        // If we're back to 2 players, remove random numbers
        if (savedData.numPlayers === 2) {
          savedData.players.forEach(player => {
            player.randomNumber = null;
          });
          console.log("Removed random numbers - back to 2 players");
        }
      }

      // Update localStorage with new data
      localStorage.setItem("scoreData", JSON.stringify(savedData));

      // Regenerate table with updated data (should save since this is user action)
      generateTable(savedData, true);

      // Show success message
      showToast(`✅ Player deleted successfully`, "success", 3000);
    }

    // Update the generateTable function to include the Add Player button at the end
    function generateTable(savedData = null, shouldSave = true) {
      let numPlayers;
      let playersData = [];

      if (savedData && savedData.numPlayers) {
        numPlayers = savedData.numPlayers;
        playersData = savedData.players || [];
      } else {
        // Get existing data if not provided
        const saved = localStorage.getItem("scoreData");
        if (saved) {
          const data = JSON.parse(saved);
          numPlayers = data.numPlayers || 2;
          playersData = data.players || [];
        } else {
          // Default to 2 players WITHOUT random numbers
          numPlayers = 2;
          
          playersData = [
            {
              name: "Player 1",
              scores: Array(10).fill(-1),
              randomNumber: null // No random number for 2 players
            },
            {
              name: "Player 2", 
              scores: Array(10).fill(-1),
              randomNumber: null // No random number for 2 players
            }
          ];
        }
      }

      // Only assign random numbers if more than 2 players AND for backward compatibility
      if (numPlayers > 2) {
        const existingNumbers = getExistingRandomNumbers({ players: playersData });
        playersData.forEach(player => {
          if (!player.randomNumber) {
            player.randomNumber = generateRandomNumber(existingNumbers);
            existingNumbers.push(player.randomNumber);
          }
        });

        // Sort players by random number only when there are more than 2 players
        playersData = sortPlayersByRandomNumber(playersData);
      }

      // Determine header text and whether to show random numbers
      const showRandomNumbers = numPlayers > 2;
      const headerText = showRandomNumbers ? "Player (#)" : "Player";

      let html = `
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
  <h2 style="margin: 0;">Score</h2>
  <button onclick="postRoundResultsToWhatsApp()" style="
    background: linear-gradient(135deg, #25d366, #128c7e);
    color: white;
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    font-weight: 600;
    cursor: pointer;
    font-size: 12px;
    box-shadow: 0 2px 4px rgba(37, 211, 102, 0.2);
    transition: all 0.3s ease;
    display: none;
    align-items: center;
    gap: 4px;
  " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 3px 6px rgba(37, 211, 102, 0.3)'" 
     onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(37, 211, 102, 0.2)'">
    <span>📱</span> Share Round
  </button>
</div>
<div class="table-container">
  <table>
    <thead>
      <tr style="background: linear-gradient(135deg, #343a40, #495057); box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <th style="
          border: 1px solid #495057; 
          padding: 12px 8px; 
          text-align: left; 
          background: linear-gradient(135deg, #6c757d, #495057);
          color: white;
          font-weight: 700;
          font-size: 14px;
          text-shadow: 0 1px 2px rgba(0,0,0,0.3);
          position: sticky;
          left: 0;
          z-index: 11;
          box-shadow: 2px 0 4px rgba(0,0,0,0.1);
        ">
          <div style="display: flex; align-items: center; gap: 6px;">
            <span>👤</span>
            <span>${headerText}</span>
          </div>
        </th>`;

      for (let round = 1; round <= 10; round++) {
        html += `<th style="
          border: 1px solid #495057; 
          padding: 12px 8px; 
          text-align: center; 
          background: linear-gradient(135deg, #007bff, #0056b3);
          color: white;
          font-weight: 700;
          font-size: 13px;
          text-shadow: 0 1px 2px rgba(0,0,0,0.3);
          position: relative;
          min-width: 70px;
        ">
          <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
            <span style="font-size: 16px;">🎯</span>
            <span>Round ${round}</span>
          </div>
        </th>`;
      }
      
      // Add delete column header
      html += `<th style="
        border: 1px solid #495057; 
        padding: 12px 8px; 
        text-align: center; 
        background: linear-gradient(135deg, #dc3545, #c82333);
        color: white;
        font-weight: 700;
        font-size: 12px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        position: relative;
        min-width: 60px;
      ">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
          <span style="font-size: 14px;">🗑️</span>
          <span>Delete</span>
        </div>
      </th>`;
      
      html += `</tr></thead><tbody>`;

      for (let i = 1; i <= numPlayers; i++) {
        const playerData = playersData[i - 1] || { 
          name: `Player ${i}`, 
          scores: Array(10).fill(-1), 
          randomNumber: null 
        };
        
        const name = playerData.name || `Player ${i}`;
        const randomNumber = playerData.randomNumber || '';

        html += `<tr><td style="border: 1px solid #ccc; padding: 8px;">
          <input type="text" id="name${i}" value="${name}" 
                 data-random-number="${randomNumber}"
                 style="border: none; background: transparent; width: 100%; padding: 4px; font-size: 14px;">`;
        
        // Only show random number if there are more than 2 players AND the player has a random number
        if (showRandomNumbers && randomNumber) {
          html += `<div style="font-size: 10px; color: #6c757d; text-align: center; margin-top: 2px; font-weight: 600;">#${randomNumber}</div>`;
        }
        
        html += `</td>`;

        for (let j = 1; j <= 10; j++) {
          const val = playerData.scores && playerData.scores[j - 1] !== undefined 
            ? playerData.scores[j - 1] 
            : -1;
          html += `<td style="border: 1px solid #ccc; padding: 8px; text-align: center; min-width: 60px;"><input type="number" id="p${i}r${j}" value="${val}" min="-1" max="100" style="border: none; background: transparent; width: 100%; text-align: center; padding: 4px; font-size: 14px; min-width: 50px;"></td>`;
        }
        
        // Add delete button cell
        html += `<td style="border: 1px solid #ccc; padding: 8px; text-align: center; min-width: 60px;">
          <button onclick="deletePlayer(${i})" style="
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
            min-width: 45px;
          " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 2px 4px rgba(220, 53, 69, 0.4)'" 
             onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'"
             title="Delete ${name}">
            🗑️
          </button>
        </td>`;
        
        html += "</tr>";
      }

      html += "</tbody></table></div>";

      // Add the "Add Player" button after the table
      html += `
<div style="margin-top: 10px;">
  <button onclick="addPlayer()" class="add-player-btn" style="padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
    + Add Player
  </button>
</div>`;

      // Save current scroll position before updating table
      const tableContainer = document.querySelector('.table-container');
      let savedScrollLeft = 0;
      let savedScrollTop = 0;
      
      if (tableContainer) {
        savedScrollLeft = tableContainer.scrollLeft;
        savedScrollTop = tableContainer.scrollTop;
      }

      document.getElementById("scoreTableContainer").innerHTML = html;

      // Restore scroll position after table update
      setTimeout(() => {
        const newTableContainer = document.querySelector('.table-container');
        if (newTableContainer && (savedScrollLeft > 0 || savedScrollTop > 0)) {
          newTableContainer.scrollLeft = savedScrollLeft;
          newTableContainer.scrollTop = savedScrollTop;
        }
        
        // Update WhatsApp buttons after table is rendered
        updateWhatsAppButtons();
      }, 0);

      // Add event listeners to inputs (only if not in view-only mode)
      if (!isViewOnlyMode) {
        addInputEventListeners();
      }

      // Apply color coding to existing scores
      colorScoreInputs();

      // Apply view-only restrictions if in view-only mode
      if (isViewOnlyMode) {
        applyViewOnlyRestrictions();
      }

      // Save the new state and calculate scores (only if shouldSave is true)
      if (shouldSave !== false) {
        saveData();
      }
      calculateScores();

      // Update Game ID display
      updateGameIdDisplay();
      
      // Update WhatsApp button visibility
      updateWhatsAppButtons();
    }

    // Function to add event listeners to input fields
    function addInputEventListeners() {
      // Add listeners to name inputs
      const nameInputs = document.querySelectorAll('input[id^="name"]');
      nameInputs.forEach(input => {
        input.addEventListener('input', function() {
          if (!isViewOnlyMode) {
            saveData();
            calculateScores();
          }
        });
      });

      // Add listeners to score inputs
      const scoreInputs = document.querySelectorAll('input[id^="p"][id*="r"]');
      scoreInputs.forEach(input => {
        input.addEventListener('input', function() {
          if (!isViewOnlyMode) {
            saveData();
            calculateScores();
            colorScoreInputs();
          }
        });
      });
    }

    // Update the colorScoreInputs function with column-wide border highlighting
    function colorScoreInputs() {
      const numPlayers =
        document.querySelectorAll('input[id^="name"]').length;

      // First, reset all column borders and remove any existing column classes
      for (let j = 1; j <= 10; j++) {
        const headerCell = document.querySelector(`table th:nth-child(${j + 1})`);
        if (headerCell) {
          headerCell.style.border = "1px solid #ccc";
          headerCell.style.borderLeft = "1px solid #ccc";
          headerCell.style.borderRight = "1px solid #ccc";
          headerCell.style.borderTop = "1px solid #ccc";
          headerCell.style.borderBottom = "1px solid #ccc";
        }
        
        for (let i = 1; i <= numPlayers; i++) {
          const cell = document.querySelector(`table tbody tr:nth-child(${i}) td:nth-child(${j + 1})`);
          if (cell) {
            cell.style.border = "1px solid #ccc";
            cell.style.borderLeft = "1px solid #ccc";
            cell.style.borderRight = "1px solid #ccc";
            cell.style.borderTop = "1px solid #ccc";
            cell.style.borderBottom = "1px solid #ccc";
          }
        }
      }

      // Check each round for negative values and apply styling
      for (let j = 1; j <= 10; j++) {
        let hasNegativeValue = false;
        let hasValidNonNegativeValue = false;
        let allValidScores = true;
        
        // Check if any player has negative score and if all have non-negative scores in this round
        for (let i = 1; i <= numPlayers; i++) {
          const input = document.getElementById(`p${i}r${j}`);
          if (input) {
            const val = parseInt(input.value);
            if (!isNaN(val)) {
              if (val < 0 || val === -1) {
                hasNegativeValue = true;
              } else if (val >= 0) {
                hasValidNonNegativeValue = true;
              }
            } else {
              // Empty or invalid value - treat as negative
              hasNegativeValue = true;
              allValidScores = false;
            }
          } else {
            // No input element - treat as negative
            hasNegativeValue = true;
            allValidScores = false;
          }
        }
        
        // Apply column-wide border styling based on round status
        const headerCell = document.querySelector(`table th:nth-child(${j + 1})`);
        
        if (hasNegativeValue) {
          // Red outside border for rounds with negative scores
          if (headerCell) {
            headerCell.style.borderLeft = "3px solid #dc3545";
            headerCell.style.borderRight = "3px solid #dc3545";
            headerCell.style.borderTop = "3px solid #dc3545";
          }
          
          for (let i = 1; i <= numPlayers; i++) {
            const cell = document.querySelector(`table tbody tr:nth-child(${i}) td:nth-child(${j + 1})`);
            if (cell) {
              cell.style.borderLeft = "3px solid #dc3545";
              cell.style.borderRight = "3px solid #dc3545";
              // Apply bottom border only to the last row
              if (i === numPlayers) {
                cell.style.borderBottom = "3px solid #dc3545";
              }
            }
          }
        } else if (hasValidNonNegativeValue && allValidScores) {
          // Green outside border for rounds where all players have non-negative scores (including zero)
          if (headerCell) {
            headerCell.style.borderLeft = "3px solid #28a745";
            headerCell.style.borderRight = "3px solid #28a745";
            headerCell.style.borderTop = "3px solid #28a745";
          }
          
          for (let i = 1; i <= numPlayers; i++) {
            const cell = document.querySelector(`table tbody tr:nth-child(${i}) td:nth-child(${j + 1})`);
            if (cell) {
              cell.style.borderLeft = "3px solid #28a745";
              cell.style.borderRight = "3px solid #28a745";
              // Apply bottom border only to the last row
              if (i === numPlayers) {
                cell.style.borderBottom = "3px solid #28a745";
              }
            }
          }
        }
        // If neither condition is met, the default border (already set above) remains
      }

      // Apply individual cell color coding
      for (let i = 1; i <= numPlayers; i++) {
        for (let j = 1; j <= 10; j++) {
          const input = document.getElementById(`p${i}r${j}`);
          if (input) {
            const val = parseInt(input.value);

            if (isNaN(val) || val === -1) {
              input.style.color = "#6c757d"; // Gray for -1
              input.style.fontStyle = "italic";
            } else if (val < 0) {
              input.style.color = "#dc3545"; // Red for negative scores
              input.style.fontStyle = "normal";
              input.style.fontWeight = "bold";
            } else if (val < 40) {
              input.style.color = "#28a745"; // Green for low scores (good)
              input.style.fontStyle = "normal";
              input.style.fontWeight = "normal";
            } else if (val >= 40 && val <= 60) {
              input.style.color = "#ffc107"; // Yellow for medium scores
              input.style.fontStyle = "normal";
              input.style.fontWeight = "normal";
            } else {
              input.style.color = "#dc3545"; // Red for high scores (bad)
              input.style.fontStyle = "normal";
              input.style.fontWeight = "normal";
            }
          }
        }
      }
    }

    // Function to calculate current round based on completed entries
    function getCurrentRound() {
      const numPlayers = document.querySelectorAll('input[id^="name"]').length;
      
      // Check rounds 1-10
      for (let round = 1; round <= 10; round++) {
        let completedPlayers = 0;
        
        // Check if all players have entered scores for this round
        for (let player = 1; player <= numPlayers; player++) {
          const scoreInput = document.getElementById(`p${player}r${round}`);
          if (scoreInput && scoreInput.value !== '' && scoreInput.value !== '-1') {
            completedPlayers++;
          }
        }
        
        // If not all players completed this round, this is the current round
        if (completedPlayers < numPlayers) {
          return `R${round}`;
        }
      }
      
      // All rounds completed
      return 'GAME OVER';
    }

    // Update the calculateScores function to remove settlement info from leaderboard
    function calculateScores() {
      // Get number of players from actual table
      const numPlayers =
        document.querySelectorAll('input[id^="name"]').length;
      const scores = [];
      const pointValue =
        parseFloat(document.getElementById("pointValue").value) || 0.15;
      const gstPercent =
        parseFloat(document.getElementById("gstPercent").value) || 25.0;

      for (let i = 1; i <= numPlayers; i++) {
        let total = 0;
        for (let j = 1; j <= 10; j++) {
          const scoreInput = document.getElementById(`p${i}r${j}`);
          if (scoreInput) {
            const val = parseInt(scoreInput.value);
            total += isNaN(val) || val === -1 ? 0 : val;
          }
        }
        const nameInput = document.getElementById(`name${i}`);
        const name = nameInput ? nameInput.value.trim() : `Player ${i}`;
        const randomNumber = nameInput ? nameInput.dataset.randomNumber : null;
        scores.push({ name, total, randomNumber });
      }

      // Keep original order for chart
      const originalOrderScores = [...scores];

      // Sort for leaderboard (low score wins)
      const sortedScores = [...scores].sort((a, b) => a.total - b.total);

      // Calculate total of all scores
      const totalAllScores = sortedScores.reduce(
        (sum, score) => sum + score.total,
        0
      );

      // Calculate gross amounts and GST using correct Rummy formula
      sortedScores.forEach((score) => {
        // Formula: (Total of all scores - Player's score × Number of players) × Point value
        score.grossAmount =
          Math.round((totalAllScores - score.total * numPlayers) * pointValue);

        // GST is only paid by winners (those with positive gross amount)
        if (score.grossAmount > 0) {
          score.gstPaid = Math.round((score.grossAmount * gstPercent) / 100);
          score.netAmount = score.grossAmount - score.gstPaid;
        } else {
          score.gstPaid = 0; // Losers don't pay GST
          score.netAmount = score.grossAmount; // Same as gross for losers
        }
      });

      // Calculate total GST collected
      const totalGstCollected = sortedScores.reduce(
        (sum, score) => sum + score.gstPaid,
        0
      );

      // Calculate current round
      const currentRound = getCurrentRound();

      // Create leaderboard table WITHOUT settlement explanation
      let leaderboardHtml = `
<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
  <h2 style="margin: 0;">Standings</h2>
  <button onclick="postLeaderboardToWhatsApp()" style="
    background: linear-gradient(135deg, #128c7e, #075e54);
    color: white;
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    font-weight: 600;
    cursor: pointer;
    font-size: 12px;
    box-shadow: 0 2px 4px rgba(18, 140, 126, 0.2);
    transition: all 0.3s ease;
    display: none;
    align-items: center;
    gap: 4px;
  " onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 3px 6px rgba(18, 140, 126, 0.3)'" 
     onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 4px rgba(18, 140, 126, 0.2)'">
    <span>🏆</span> Share Results
  </button>
</div>
<div style="
  text-align: center; 
  margin-bottom: 12px; 
  padding: 8px 12px; 
  background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 50%, #fff3e0 100%); 
  border-radius: 12px; 
  border: 2px solid #e1bee7;
  box-shadow: 0 4px 12px rgba(161, 136, 205, 0.2);
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(161, 136, 205, 0.25)'" 
   onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(161, 136, 205, 0.2)'">
  <div style="
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    animation: shimmer 3s ease-in-out infinite;
    pointer-events: none;
  "></div>
  <div style="position: relative; z-index: 1;">
    <div style="display: flex; align-items: center; justify-content: center; gap: 8px; flex-wrap: wrap;">
      <div style="
        display: flex; 
        align-items: center; 
        gap: 4px;
        background: rgba(255,255,255,0.6);
        padding: 4px 8px;
        border-radius: 16px;
        border: 1px solid rgba(74, 20, 140, 0.2);
      ">
        <span style="font-size: 14px;">💰</span>
        <span style="font-size: 13px; color: #4a148c; font-weight: 700;">₹${pointValue}</span>
        <span style="font-size: 11px; color: #6a1b9a; font-weight: 500;">/point</span>
      </div>
      <div style="
        display: flex; 
        align-items: center; 
        gap: 4px;
        background: rgba(255,255,255,0.6);
        padding: 4px 8px;
        border-radius: 16px;
        border: 1px solid rgba(74, 20, 140, 0.2);
      ">
        <span style="font-size: 14px;">📊</span>
        <span style="font-size: 13px; color: #4a148c; font-weight: 700;">${gstPercent}%</span>
        <span style="font-size: 11px; color: #6a1b9a; font-weight: 500;">GST</span>
      </div>
      <div style="
        display: flex; 
        align-items: center; 
        gap: 4px;
        background: rgba(255,255,255,0.6);
        padding: 4px 8px;
        border-radius: 16px;
        border: 1px solid rgba(74, 20, 140, 0.2);
      ">
        <span style="font-size: 14px;">${currentRound === 'GAME OVER' ? '🏁' : '🎯'}</span>
        <span style="font-size: 13px; color: #4a148c; font-weight: 700;">${currentRound}</span>
        <span style="font-size: 11px; color: #6a1b9a; font-weight: 500;">${currentRound === 'GAME OVER' ? '' : 'Round'}</span>
      </div>
    </div>
  </div>
</div>
<style>
@keyframes shimmer {
  0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
  50% { transform: translateX(100%) translateY(100%) rotate(45deg); }
  100% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
}
</style>
<table class="leaderboard-table" style="
  width: auto !important; 
  min-width: auto !important; 
  max-width: 650px !important; 
  border-collapse: collapse; 
  margin-top: 10px; 
  display: table !important;
  table-layout: auto !important;
">
  <thead>
    <tr style="background: linear-gradient(135deg, #212529, #343a40) !important;">
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 50px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Rank</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: left; width: auto !important; min-width: 80px !important; max-width: 100px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Player</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 50px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Score</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Gross Amount</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 65px !important; font-size: 12px; color: white !important; font-weight: bold !important;">GST (${gstPercent}%)</th>
      <th style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 12px; color: white !important; font-weight: bold !important;">Net Amount</th>
    </tr>
  </thead>
  <tbody>`;

      sortedScores.forEach((score, index) => {
        // Add medal icons with rank numbers
        let rankDisplay;
        if (index === 0) {
          rankDisplay = "🥇";
        } else if (index === 1) {
          rankDisplay = "🥈";
        } else if (index === 2) {
          rankDisplay = "🥉";
        } else {
          rankDisplay = `${index + 1}`;
        }

        const grossAmount = score.grossAmount;
        const gstPaid = score.gstPaid;
        const netAmount = score.netAmount;

        // Determine if this is a winner or loser for styling
        const isWinner = grossAmount > 0;
        const isLoser = grossAmount < 0;

        let grossStyle = "";
        let gstStyle = "";
        let netStyle = "";

        if (isWinner) {
          grossStyle = "color: #28a745; font-weight: bold;"; // Green for receiving money
          gstStyle = "color: #dc3545; font-weight: bold;"; // Red for GST paid
          netStyle = "color: #28a745; font-weight: bold;"; // Green for net amount received
        } else if (isLoser) {
          grossStyle = "color: #dc3545; font-weight: bold;"; // Red for paying money
          gstStyle = "color: #6c757d;"; // Gray for no GST
          netStyle = "color: #dc3545; font-weight: bold;"; // Red for net amount paid
        } else {
          grossStyle = "color: #6c757d;"; // Gray for break-even
          gstStyle = "color: #6c757d;"; // Gray for no GST
          netStyle = "color: #6c757d;"; // Gray for break-even
        }

        leaderboardHtml += `
  <tr>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; font-weight: bold; width: 50px !important; font-size: 11px;">${rankDisplay}</td>
    <td style="border: 1px solid #ccc; padding: 6px; width: auto !important; font-size: 11px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
      ${score.name}${score.randomNumber && numPlayers > 2 ? ` <span style="color: #6c757d; font-size: 10px;">(#${score.randomNumber})</span>` : ''}
    </td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 50px !important; font-size: 11px; font-weight: 600;">${score.total
          }</td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 11px; ${grossStyle}">₹${grossAmount}</td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 65px !important; font-size: 11px; ${gstStyle}">₹${gstPaid}</td>
    <td style="border: 1px solid #ccc; padding: 6px; text-align: center; width: 80px !important; font-size: 11px; ${netStyle}">₹${netAmount}</td>
  </tr>`;
      });

      leaderboardHtml += `
  </tbody>
  <tfoot>
    <tr style="background-color: #e9ecef; font-weight: bold;">
      <td colspan="4" style="border: 1px solid #ccc; padding: 6px; text-align: right; font-size: 12px; color: #6c757d;">Total GST Collected:</td>
      <td style="border: 1px solid #ccc; padding: 6px; text-align: center; font-size: 12px; color: #28a745; font-weight: bold;">₹${Math.round(totalGstCollected)}</td>
      <td style="border: 1px solid #ccc; padding: 6px; text-align: center; font-size: 12px; color: #6c757d;">-</td>
    </tr>
  </tfoot>
</table>`;

      document.getElementById("leaderboard").innerHTML = leaderboardHtml;
      updateChart(originalOrderScores); // Pass original order to chart
      
      // Update WhatsApp buttons after leaderboard is rendered
      updateWhatsAppButtons();

      // Color code the leaderboard scores
      sortedScores.forEach((score, index) => {
        const scoreCell = document.querySelector(
          `.leaderboard-table tbody tr:nth-child(${index + 1
          }) td:nth-child(3)`
        );
        if (scoreCell) {
          if (score.total < 40) {
            scoreCell.style.color = "#28a745"; // Green for good scores
          } else if (score.total >= 40 && score.total <= 60) {
            scoreCell.style.color = "#ffc107"; // Yellow for medium scores
          } else {
            scoreCell.style.color = "#dc3545"; // Red for high scores
          }
        }
      });

      // Add settlement explanation AFTER chart is updated
      updateSettlementInfo(gstPercent, numPlayers, pointValue);
      

    }

    function updateChart(scores) {
      const ctx = document.getElementById("scoreChart").getContext("2d");
      const labels = scores.map((s) => s.name);
      const data = scores.map((s) => s.total);

      // Find min and max scores for relative coloring
      const minScore = Math.min(...data);
      const maxScore = Math.max(...data);
      const range = maxScore - minScore;

      const backgroundColors = data.map((score) => {
        if (range === 0) {
          // All scores are the same
          return "rgb(128, 128, 128)"; // Gray
        }

        // Calculate relative position (0 = best, 1 = worst)
        const position = (score - minScore) / range;

        if (position <= 0.33) {
          // Best third - Green shades (darker green for better scores)
          const green = Math.round(255 - position * 0.33 * 100); // 255 to 155
          return `rgb(0, ${green}, 0)`;
        } else if (position <= 0.66) {
          // Middle third - Yellow/Orange shades
          const progress = (position - 0.33) / 0.33; // 0 to 1 within this range
          const red = Math.round(255);
          const green = Math.round(255 - progress * 127); // 255 to 128
          return `rgb(${red}, ${green}, 0)`;
        } else {
          // Worst third - Red shades (darker red for worse scores)
          const progress = (position - 0.66) / 0.34; // 0 to 1 within this range
          const red = Math.round(200 + progress * 55); // 200 to 255
          return `rgb(${red}, 0, 0)`;
        }
      });

      if (chart) chart.destroy();

      chart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: labels,
          datasets: [
            {
              label: "Total Score",
              data: data,
              backgroundColor: backgroundColors,
              borderColor: "rgba(0,0,0,0.2)",
              borderWidth: 1,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: {
              display: false,
            },
          },
          scales: {
            y: {
              beginAtZero: true,
            },
            x: {
              // Removed title
            },
          },
        },
      });

      // After chart is rendered, add settlement info
      setTimeout(() => {
        // Get current values for settlement info
        const gstPercent =
          parseFloat(document.getElementById("gstPercent").value) || 18.0;
        const numPlayers =
          document.querySelectorAll('input[id^="name"]').length;
        const pointValue =
          parseFloat(document.getElementById("pointValue").value) || 0.15;
        updateSettlementInfo(gstPercent, numPlayers, pointValue);
      }, 100);
    }

    // New function to add settlement info after the chart
    function updateSettlementInfo(gstPercent, numPlayers, pointValue) {
      // Remove existing settlement info if any
      const existingInfo = document.getElementById("settlementInfo");
      if (existingInfo) {
        existingInfo.remove();
      }

      // Create settlement explanation
      const settlementHtml = `
<div id="settlementInfo" style="margin-top: 30px; padding: 15px; background-color: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
  <h4 style="margin: 0 0 12px 0; color: #495057; font-size: 16px;">💡 How Settlement Works:</h4>
  <ul style="margin: 0; padding-left: 20px; font-size: 14px; color: #6c757d; line-height: 1.5;">
    <li><strong style="color: #28a745;">Winners (Green):</strong> Receive money but pay ${gstPercent}% GST on winnings</li>
    <li><strong style="color: #dc3545;">Losers (Red):</strong> Pay money, no GST required</li>
    <li><strong>Formula:</strong> (Total All Scores - Your Score × ${numPlayers}) × ₹${pointValue}</li>
    <li><strong>GST:</strong> Only winners pay ${gstPercent}% GST on positive amounts</li>
    <li><strong>Net Amount:</strong> Gross Amount - GST (for winners) or just Gross Amount (for losers)</li>
  </ul>
  <div style="margin-top: 10px; padding: 8px; background-color: #e3f2fd; border-radius: 4px; font-size: 12px; color: #1565c0;">
    <strong>💰 Example:</strong> If you score 25 points in a ${numPlayers}-player game with ₹${pointValue}/point:<br>
    Your settlement = (Total of all ${numPlayers} scores - 25 × ${numPlayers}) × ₹${pointValue}
  </div>
</div>`;

      // Add after the chart container
      const chartContainer = document.querySelector(".chart-container");
      if (chartContainer) {
        chartContainer.insertAdjacentHTML("afterend", settlementHtml);
      }
    }

    // Add these cloud functions after your existing functions

    // Generate or get game ID (no cloud operations)
    function getGameId() {
      let gameId = localStorage.getItem("gameId");
      if (!gameId) {
        gameId = Math.random().toString(36).substr(2, 9).toUpperCase();
        localStorage.setItem("gameId", gameId);
      }
      return gameId;
    }

    // Save to cloud - saves to gameData collection only
    async function saveToCloud() {
      // Prevent saving in view-only mode
      if (isViewOnlyMode) {
        showToast("❌ Cannot save in View Only mode", "error");
        return;
      }

      if (!window.db) {
        showToast(
          "❌ Firebase Not Ready - Please refresh the page!",
          "error"
        );
        return;
      }

      const gameId = getGameId();
      const data = localStorage.getItem("scoreData");

      if (!data) {
        showToast("⚠️ No game data to save to cloud!", "error");
        return;
      }

      try {
        const loadingToast = showToast(
          "☁️ Saving game to cloud...",
          "loading"
        );

        // Save data to gameData collection only
        const gameDataRef = window.firestore.doc(window.db, "gameData", gameId);
        
        await window.firestore.setDoc(gameDataRef, {
          data: JSON.parse(data),
          lastUpdated: window.firestore.serverTimestamp(),
          version: "1.0",
        });

        hideLoadingToast();
        showToast(`✅ Game saved! ID: ${gameId}`, "success", 6000);
      } catch (error) {
        console.error("Save error:", error);
        hideLoadingToast();
        showToast(
          "❌ Failed to save. Check your internet connection.",
          "error"
        );
      }
    }

    // Load from cloud - with QR code scanner
    async function loadFromCloud() {
      if (!window.db) {
        showToast(
          "❌ Firebase Not Ready - Please refresh the page!",
          "error"
        );
        return;
      }

      // Check if device has camera support
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        // Fallback to text input for devices without camera
        const gameId = prompt("Enter Game ID to load game (Camera not supported):");
        if (gameId) {
          await loadGameById(gameId.trim().toUpperCase());
        }
        return;
      }

      // Open QR scanner modal and automatically start camera
      document.getElementById("qrScannerModal").style.display = "block";
      
      // Reset mode selection and PIN verification state
      currentScanMode = "view";
      isPINVerified = false;
      
      // Reset radio buttons to View Only as default
      const viewRadio = document.querySelector('input[name="scanMode"][value="view"]');
      if (viewRadio) {
        viewRadio.checked = true;
      }
      
      // Hide PIN container initially
      const pinContainer = document.getElementById("pinContainer");
      const pinInput = document.getElementById("pinInput");
      const pinMessage = document.getElementById("pinMessage");
      if (pinContainer) {
        pinContainer.style.display = "none";
      }
      if (pinInput) {
        pinInput.value = "";
      }
      if (pinMessage) {
        pinMessage.textContent = "";
      }
      
      // Clear any temporary game ID
      window.tempGameId = null;
      
      // Automatically start the camera
      setTimeout(() => {
        startQRScanner();
      }, 100); // Small delay to ensure modal is fully displayed
    }

    // QR Scanner variables
    let qrStream = null;
    let qrScanInterval = null;
    let currentCamera = "environment"; // "environment" for back camera, "user" for front camera

    // Variables to store mode and PIN verification state
    let currentScanMode = "view";
    let isPINVerified = false;
    let isViewOnlyMode = false; // Global flag to track if game is in view-only mode

    // PIN validation function - reads from games collection only
    async function validatePIN(enteredPIN) {
      const pinMessage = document.getElementById("pinMessage");
      const gameId = localStorage.getItem("gameId") || getCurrentGameIdFromScanner();
      
      if (!gameId) {
        pinMessage.textContent = "⚠️ Please scan QR code first to get Game ID";
        pinMessage.style.color = "#dc3545";
        return;
      }

      if (!window.db) {
        pinMessage.textContent = "❌ Database not ready. Please try again.";
        pinMessage.style.color = "#dc3545";
        return;
      }

      try {
        pinMessage.textContent = "🔍 Verifying PIN...";
        pinMessage.style.color = "#007bff";

        // Fetch PIN from games collection (authentication data only)
        const authDocSnap = await window.firestore.getDoc(
          window.firestore.doc(window.db, "games", gameId)
        );

        if (authDocSnap.exists()) {
          const authData = authDocSnap.data();
          const storedPIN = authData.pin;

          if (storedPIN === enteredPIN) {
            // PIN matches - immediately set PIN in localStorage to prevent race conditions
            localStorage.setItem("gamePin", storedPIN);
            console.log("PIN validation success - stored PIN in localStorage:", storedPIN);
            
            pinMessage.textContent = "✅ PIN matched! You are in Edit Mode";
            pinMessage.style.color = "#28a745";
            isPINVerified = true;
            currentScanMode = "edit";
            
            // Close scanner and load game in edit mode
            setTimeout(() => {
              closeQRScanner();
              loadGameById(gameId, "edit");
            }, 1000);
          } else {
            // PIN doesn't match
            pinMessage.textContent = "❌ PIN not matched. Switching to View Mode";
            pinMessage.style.color = "#dc3545";
            isPINVerified = false;
            currentScanMode = "view";
            
            // Switch to view mode radio button
            const viewRadio = document.querySelector('input[name="scanMode"][value="view"]');
            if (viewRadio) {
              viewRadio.checked = true;
            }
            
            // Hide PIN container after failed attempt
            setTimeout(() => {
              document.getElementById("pinContainer").style.display = "none";
            }, 2000);
          }
        } else {
          pinMessage.textContent = "❌ Game not found in cloud database";
          pinMessage.style.color = "#dc3545";
          isPINVerified = false;
          currentScanMode = "view";
        }
      } catch (error) {
        console.error("PIN validation error:", error);
        pinMessage.textContent = "❌ PIN verification failed. Network error.";
        pinMessage.style.color = "#dc3545";
        isPINVerified = false;
        currentScanMode = "view";
      }
    }

    // Helper function to get current game ID from scanner context
    function getCurrentGameIdFromScanner() {
      // This will be set when QR code is scanned but before loading
      return window.tempGameId || null;
    }

    // Manual entry function
    function manualEntry() {
      // Get the current selected mode before closing scanner
      const selectedMode = document.querySelector('input[name="scanMode"]:checked').value;
      
      closeQRScanner();
      
      const gameId = prompt("Enter Game ID to load game:");
      if (gameId && gameId.trim()) {
        const cleanGameId = gameId.trim().toUpperCase();
        
        if (selectedMode === "view") {
          // View mode - load directly
          currentScanMode = "view";
          isPINVerified = false;
          loadGameById(cleanGameId, "view");
        } else {
          // Edit mode - prompt for PIN
          const enteredPIN = prompt("Enter 4-digit PIN for Edit access:");
          if (enteredPIN && enteredPIN.trim().length === 4) {
            // Store game ID temporarily and validate PIN
            window.tempGameId = cleanGameId;
            validatePINAndLoad(cleanGameId, enteredPIN.trim());
          } else if (enteredPIN !== null) {
            // User entered invalid PIN format
            showToast("❌ Invalid PIN format. Please enter a 4-digit PIN.", "error");
          }
          // If user cancelled PIN prompt, do nothing
        }
      }
    }

    // Helper function for manual entry PIN validation - reads from games collection only
    async function validatePINAndLoad(gameId, enteredPIN) {
      if (!window.db) {
        showToast("❌ Database not ready. Please try again.", "error");
        return;
      }

      try {
        showToast("🔍 Verifying PIN...", "loading");

        // Fetch PIN from games collection (authentication data only)
        const authDocSnap = await window.firestore.getDoc(
          window.firestore.doc(window.db, "games", gameId)
        );

        if (authDocSnap.exists()) {
          const authData = authDocSnap.data();
          const storedPIN = authData.pin;

          if (storedPIN === enteredPIN) {
            // PIN matches - immediately set PIN in localStorage to prevent race conditions
            localStorage.setItem("gamePin", storedPIN);
            console.log("Manual entry PIN validation success - stored PIN in localStorage:", storedPIN);
            
            isPINVerified = true;
            currentScanMode = "edit";
            hideLoadingToast();
            loadGameById(gameId, "edit");
          } else {
            // PIN doesn't match
            hideLoadingToast();
            showToast("❌ PIN not matched. Loading in View Only mode instead.", "error", 6000);
            isPINVerified = false;
            currentScanMode = "view";
            loadGameById(gameId, "view");
          }
        } else {
          hideLoadingToast();
          showToast("❌ Game not found in cloud database", "error");
        }
      } catch (error) {
        console.error("PIN validation error:", error);
        hideLoadingToast();
        showToast("❌ PIN verification failed. Loading in View Only mode.", "error", 6000);
        isPINVerified = false;
        currentScanMode = "view";
        loadGameById(gameId, "view");
      }
    }

    // Switch camera function
    async function switchCamera() {
      const switchBtn = document.getElementById("switchCameraBtn");
      const statusText = document.getElementById("scannerStatus");
      
      // Disable button temporarily
      switchBtn.disabled = true;
      switchBtn.textContent = "🔄 Switching...";
      
      // Stop current stream
      if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
      }
      
      // Clear scanning interval
      if (qrScanInterval) {
        clearInterval(qrScanInterval);
        qrScanInterval = null;
      }
      
      // Switch camera
      currentCamera = currentCamera === "environment" ? "user" : "environment";
      
      // Restart scanner with new camera
      try {
        await startQRScanner();
        switchBtn.textContent = currentCamera === "environment" ? "📱 Front Camera" : "📹 Back Camera";
      } catch (error) {
        statusText.textContent = "❌ Failed to switch camera";
        statusText.style.color = "#dc3545";
        switchBtn.textContent = "🔄 Switch Camera";
      }
      
      switchBtn.disabled = false;
    }

    // Start QR Scanner
    async function startQRScanner() {
      const video = document.getElementById("qrScannerVideo");
      const canvas = document.getElementById("qrScannerCanvas");
      const context = canvas.getContext("2d");
      const statusText = document.getElementById("scannerStatus");

      try {
        // Update status
        statusText.textContent = "📷 Starting camera...";
        statusText.style.color = "#007bff";

        // Request camera access
        qrStream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: currentCamera, // Use current camera setting
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        
        video.srcObject = qrStream;
        video.play();

        // Show switch camera button once camera is working
        const switchBtn = document.getElementById("switchCameraBtn");
        if (switchBtn) {
          switchBtn.style.display = "inline-block";
          switchBtn.textContent = currentCamera === "environment" ? "📱 Front Camera" : "📹 Back Camera";
        }

        // Update status
        statusText.textContent = "🔍 Scanning for QR code... Position it within the green frame";
        statusText.style.color = "#28a745";

        // Wait for video to load
        video.addEventListener("loadedmetadata", () => {
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;

          // Start scanning for QR codes
          qrScanInterval = setInterval(() => {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
              context.drawImage(video, 0, 0, canvas.width, canvas.height);
              const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
              
              // Use jsQR library to decode QR code
              const code = jsQR(imageData.data, imageData.width, imageData.height);
              
              if (code && code.data) {
                // QR code found! Update visual feedback
                const scannerFrame = document.getElementById("scannerFrame");
                if (scannerFrame) {
                  scannerFrame.style.borderColor = "#ffc107";
                  scannerFrame.style.background = "rgba(255, 193, 7, 0.2)";
                  scannerFrame.innerHTML = `
                    <div style="
                      color: #ffc107;
                      font-size: 18px;
                      font-weight: bold;
                      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                      text-align: center;
                      padding: 10px;
                    ">
                      ✅ QR Code Found!<br>
                      <small>Processing...</small>
                    </div>
                  `;
                }
                
                // Get the selected mode
                const selectedMode = document.querySelector('input[name="scanMode"]:checked').value;
                const gameId = code.data.trim().toUpperCase();
                
                // Store the game ID temporarily for PIN validation
                window.tempGameId = gameId;
                
                if (selectedMode === "view") {
                  // View mode - no PIN required
                  statusText.textContent = "✅ QR Code detected! Loading in View Only mode...";
                  statusText.style.color = "#28a745";
                  showToast(`👁️ Loading in View Only mode - Game ID: ${gameId}`, "info", 4000);
                  currentScanMode = "view";
                  isPINVerified = false;
                  closeQRScanner();
                  loadGameById(gameId);
                } else {
                  // Edit mode - PIN verification required
                  statusText.textContent = "✅ QR Code detected! Please verify PIN for Edit access...";
                  statusText.style.color = "#ffc107";
                  
                  // Stop scanning since we found the QR code
                  clearInterval(qrScanInterval);
                  qrScanInterval = null;
                  
                  // Show PIN message and focus on PIN input
                  const pinInput = document.getElementById("pinInput");
                  const pinMessage = document.getElementById("pinMessage");
                  
                  if (pinMessage) {
                    pinMessage.textContent = `🔐 Enter PIN for Game ID: ${gameId}`;
                    pinMessage.style.color = "#007bff";
                  }
                  
                  if (pinInput) {
                    pinInput.focus();
                    pinInput.select();
                  }
                  
                  showToast(`🔐 QR Code found! Enter PIN to access Edit mode`, "info", 6000);
                }
              }
            }
          }, 300); // Check every 300ms
        });

      } catch (error) {
        console.error("Camera access error:", error);
        statusText.textContent = "❌ Camera access denied or not available";
        statusText.style.color = "#dc3545";
        
        // Show toast and fallback to text input after a delay
        showToast("❌ Camera access denied or not available", "error");
        
        setTimeout(() => {
          closeQRScanner();
          const gameId = prompt("Enter Game ID to load game:");
          if (gameId) {
            loadGameById(gameId.trim().toUpperCase());
          }
        }, 2000);
      }
    }

    // Close QR Scanner
    function closeQRScanner() {
      const video = document.getElementById("qrScannerVideo");
      const statusText = document.getElementById("scannerStatus");
      const switchBtn = document.getElementById("switchCameraBtn");
      
      // Stop camera stream
      if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
      }

      // Clear scanning interval
      if (qrScanInterval) {
        clearInterval(qrScanInterval);
        qrScanInterval = null;
      }

      // Reset video
      video.srcObject = null;

      // Reset status text
      if (statusText) {
        statusText.textContent = "📷 Starting camera...";
        statusText.style.color = "#007bff";
      }

      // Hide switch camera button
      if (switchBtn) {
        switchBtn.style.display = "none";
      }

      // Reset scanner frame
      const scannerFrame = document.getElementById("scannerFrame");
      if (scannerFrame) {
        scannerFrame.style.borderColor = "#00ff00";
        scannerFrame.style.background = "rgba(0, 255, 0, 0.1)";
        scannerFrame.innerHTML = `
          <div style="
            color: #00ff00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: center;
            padding: 10px;
          ">
            📱 Position QR Code Here
          </div>
        `;
      }

      // Close modal
      document.getElementById("qrScannerModal").style.display = "none";
    }

    // Load game by ID - reads from gameData collection
    async function loadGameById(gameId, mode = currentScanMode) {
      if (!gameId) return;

      try {
        showToast("📥 Loading game from cloud...", "loading");

        // Load game data from gameData collection
        const gameDataSnap = await window.firestore.getDoc(
          window.firestore.doc(window.db, "gameData", gameId)
        );

        if (gameDataSnap.exists()) {
          const cloudData = gameDataSnap.data();
          localStorage.setItem("scoreData", JSON.stringify(cloudData.data));
          localStorage.setItem("gameId", gameId);
          
          // For edit mode, we already have the PIN set from validation
          // For view mode, we don't need the PIN
          if (mode === "edit" && isPINVerified) {
            console.log("Edit mode - PIN already validated and stored");
          } else {
            console.log("View mode - no PIN needed");
          }

          // Update point value and GST from cloud
          document.getElementById("pointValue").value =
            cloudData.data.pointValue || 1.0;
          document.getElementById("gstPercent").value =
            cloudData.data.gstPercent || 18.0;

          loadData();

          // Update Game ID display
          updateGameIdDisplay();

          // Show success toast based on mode
          if (mode === "edit" && isPINVerified) {
            isViewOnlyMode = false; // Enable editing
            localStorage.setItem("gameMode", "edit"); // Store mode in localStorage
            showToast(`✅ Game loaded in Edit Mode! ID: ${gameId}`, "success", 5000);
            // Optional: Show edit mode indicator in title
            document.title = "⭐ Rummy Score Master (Edit Mode)";
            setTimeout(() => (document.title = "⭐ Rummy Score Master"), 5000);
          } else {
            isViewOnlyMode = true; // Disable editing
            localStorage.setItem("gameMode", "view"); // Store mode in localStorage
            showToast(`👁️ Game loaded in View Only Mode! ID: ${gameId}`, "info", 5000);
            // Optional: Show view mode indicator in title
            document.title = "⭐ Rummy Score Master (View Only)";
            setTimeout(() => (document.title = "⭐ Rummy Score Master"), 5000);
          }

          // Apply view-only restrictions if needed
          if (isViewOnlyMode) {
            applyViewOnlyRestrictions();
            // Start real-time listener for view-only mode
            startRealtimeListener(gameId);
          } else {
            removeViewOnlyRestrictions();
            // Stop any existing real-time listener for edit mode
            stopRealtimeListener();
          }

          // Clear temporary game ID
          window.tempGameId = null;
          
          // Show WhatsApp buttons for loaded game
          updateWhatsAppButtons();
        } else {
          showToast(
            "❌ Game ID not found. Please check and try again.",
            "error"
          );
        }
      } catch (error) {
        console.error("Load error:", error);
        showToast(
          "❌ Failed to load game. Check your internet connection.",
          "error"
        );
      }
    }

    // Function to apply view-only restrictions
    function applyViewOnlyRestrictions() {
      // Disable all score inputs
      const scoreInputs = document.querySelectorAll('input[id^="p"][id*="r"]');
      scoreInputs.forEach(input => {
        input.disabled = true;
        input.style.backgroundColor = "#f8f9fa";
        input.style.color = "#6c757d";
        input.style.cursor = "not-allowed";
        input.title = "View Only Mode - Editing disabled";
      });

      // Disable all player name inputs
      const nameInputs = document.querySelectorAll('input[id^="name"]');
      nameInputs.forEach(input => {
        input.disabled = true;
        input.style.backgroundColor = "#f8f9fa";
        input.style.color = "#6c757d";
        input.style.cursor = "not-allowed";
        input.title = "View Only Mode - Editing disabled";
      });

      // Hide Add Player button
      const addPlayerBtn = document.querySelector('.add-player-btn');
      if (addPlayerBtn) {
        addPlayerBtn.style.display = "none";
      }

      // Disable all Delete Player buttons
      const deleteButtons = document.querySelectorAll('button[onclick^="deletePlayer"]');
      deleteButtons.forEach(button => {
        button.disabled = true;
        button.style.backgroundColor = "#6c757d";
        button.style.color = "#ffffff";
        button.style.cursor = "not-allowed";
        button.style.opacity = "0.6";
        button.title = "View Only Mode - Cannot delete players";
        button.textContent = "🔒";
      });

      // Disable Point Value and GST inputs
      const pointValueInput = document.getElementById("pointValue");
      const gstInput = document.getElementById("gstPercent");
      if (pointValueInput) {
        pointValueInput.disabled = true;
        pointValueInput.style.backgroundColor = "#f8f9fa";
        pointValueInput.style.color = "#6c757d";
        pointValueInput.style.cursor = "not-allowed";
        pointValueInput.title = "View Only Mode - Settings cannot be changed";
      }
      if (gstInput) {
        gstInput.disabled = true;
        gstInput.style.backgroundColor = "#f8f9fa";
        gstInput.style.color = "#6c757d";
        gstInput.style.cursor = "not-allowed";
        gstInput.title = "View Only Mode - Settings cannot be changed";
      }

      // Add visual indicator for view-only mode
      addViewOnlyIndicator();
    }

    // Function to remove view-only restrictions
    function removeViewOnlyRestrictions() {
      // Enable all score inputs
      const scoreInputs = document.querySelectorAll('input[id^="p"][id*="r"]');
      scoreInputs.forEach(input => {
        input.disabled = false;
        input.style.backgroundColor = "";
        input.style.color = "";
        input.style.cursor = "";
        input.title = "";
      });

      // Enable all player name inputs
      const nameInputs = document.querySelectorAll('input[id^="name"]');
      nameInputs.forEach(input => {
        input.disabled = false;
        input.style.backgroundColor = "";
        input.style.color = "";
        input.style.cursor = "";
        input.title = "";
      });

      // Show Add Player button
      const addPlayerBtn = document.querySelector('.add-player-btn');
      if (addPlayerBtn) {
        addPlayerBtn.style.display = "";
      }

      // Enable all Delete Player buttons
      const deleteButtons = document.querySelectorAll('button[onclick^="deletePlayer"]');
      deleteButtons.forEach(button => {
        button.disabled = false;
        button.style.backgroundColor = "";
        button.style.color = "";
        button.style.cursor = "";
        button.style.opacity = "";
        button.title = "";
        button.textContent = "🗑️";
      });

      // Keep Point Value and GST inputs disabled if game is already started
      // (they should only be enabled for new games)
      const gameData = localStorage.getItem("scoreData");
      if (!gameData) {
        const pointValueInput = document.getElementById("pointValue");
        const gstInput = document.getElementById("gstPercent");
        if (pointValueInput) {
          pointValueInput.disabled = false;
          pointValueInput.style.backgroundColor = "";
          pointValueInput.style.color = "";
          pointValueInput.style.cursor = "";
          pointValueInput.title = "";
        }
        if (gstInput) {
          gstInput.disabled = false;
          gstInput.style.backgroundColor = "";
          gstInput.style.color = "";
          gstInput.style.cursor = "";
          gstInput.title = "";
        }
      }

      // Remove view-only indicator
      removeViewOnlyIndicator();

    }

    // Function to add visual indicator for view-only mode
    function addViewOnlyIndicator() {
      // Remove existing indicator if any
      removeViewOnlyIndicator();

      // Add indicator to the header
      const header = document.querySelector('h1');
      if (header) {
        const indicator = document.createElement('div');
        indicator.id = 'viewOnlyIndicator';
        indicator.innerHTML = `
          <div style="
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            text-align: center;
            margin: 10px auto;
            max-width: 300px;
            box-shadow: 0 2px 8px rgba(23, 162, 184, 0.3);
            animation: pulse 2s infinite;
          ">
            👁️ VIEW ONLY MODE - Editing Disabled
          </div>
        `;
        header.insertAdjacentElement('afterend', indicator);
      }
    }

    // Function to remove visual indicator
    function removeViewOnlyIndicator() {
      const indicator = document.getElementById('viewOnlyIndicator');
      if (indicator) {
        indicator.remove();
      }
    }

    // Auto-save to cloud (silent) - saves to gameData collection only
    async function autoSaveToCloud() {
      // Prevent auto-save in view-only mode
      if (isViewOnlyMode) {
        console.log("Auto-save blocked - View Only Mode");
        return;
      }

      const gameId = localStorage.getItem("gameId");
      if (!gameId || !window.db) return;

      const data = localStorage.getItem("scoreData");
      if (!data) return;

      try {
        // Save data to gameData collection (no need to check games collection)
        await window.firestore.setDoc(
          window.firestore.doc(window.db, "gameData", gameId),
          {
            data: JSON.parse(data),
            lastUpdated: window.firestore.serverTimestamp(),
            version: "1.0",
          }
        );

        console.log("Auto-save: Game data saved to gameData collection for gameId:", gameId);

        // Show sync indicator briefly
        document.title = "⭐ Rummy Score Master (Synced)";
        setTimeout(() => (document.title = "⭐ Rummy Score Master"), 2000);
      } catch (error) {
        console.error("Auto-save failed:", error);
      }
    }

    // Real-time listener functions for view-only mode
    function startRealtimeListener(gameId) {
      // Only start listener in view-only mode
      if (!isViewOnlyMode || !gameId || !window.db) {
        console.log("Not starting real-time listener: isViewOnlyMode=", isViewOnlyMode, "gameId=", gameId, "window.db=", !!window.db);
        return;
      }

      // Stop any existing listener first
      stopRealtimeListener();

      console.log("🔴 Starting real-time listener for gameId:", gameId);

      try {
        // Create listener for the gameData document
        const gameDataRef = window.firestore.doc(window.db, "gameData", gameId);
        
        // Store gameId in localStorage to ensure persistence across refreshes
        localStorage.setItem("gameId", gameId);
        
        realtimeListener = window.firestore.onSnapshot(gameDataRef, (docSnapshot) => {
          if (docSnapshot.exists()) {
            const cloudData = docSnapshot.data();
            const cloudUpdateTime = cloudData.lastUpdated;
            
            // Check if this is a newer update than what we have
            if (!lastKnownUpdateTime || 
                (cloudUpdateTime && cloudUpdateTime.toMillis() > lastKnownUpdateTime)) {
              
              console.log("📥 Real-time update received for gameId:", gameId);
              
              // Update last known time
              lastKnownUpdateTime = cloudUpdateTime ? cloudUpdateTime.toMillis() : Date.now();
              
              // Update local data
              localStorage.setItem("scoreData", JSON.stringify(cloudData.data));
              
              // Update point value and GST from cloud
              document.getElementById("pointValue").value = cloudData.data.pointValue || 1.0;
              document.getElementById("gstPercent").value = cloudData.data.gstPercent || 18.0;
              
              // Reload the table and calculations without saving (to prevent loops)
              console.log("Updating tables from real-time data");
              generateTable(cloudData.data, false);
              calculateScores();
              
              // Force UI updates
              updateWhatsAppButtons();
              
              // Show subtle notification
              showRealtimeUpdateNotification();
              
              // Update page title briefly to show sync
              document.title = "⭐ Rummy Score Master (Updated)";
              setTimeout(() => {
                const mode = isViewOnlyMode ? " (View Only)" : "";
                document.title = "⭐ Rummy Score Master" + mode;
              }, 3000);
            }
          } else {
            console.log("⚠️ Game document deleted or not found");
            showToast("⚠️ Game data not found. Game may have been deleted.", "error");
          }
        }, (error) => {
          console.error("Real-time listener error:", error);
          // Don't show error to user for network issues, just log it
          if (error.code !== 'permission-denied') {
            console.warn("Real-time listener failed, will retry on next load");
          }
        });

        
      } catch (error) {
        console.error("Failed to start real-time listener:", error);
      }
    }

    function stopRealtimeListener() {
      if (realtimeListener) {
        console.log("🔴 Stopping real-time listener");
        realtimeListener(); // Call the unsubscribe function
        realtimeListener = null;
        lastKnownUpdateTime = null;
      }
    }

    // View-only mode is handled by real-time Firestore listeners

    function showRealtimeUpdateNotification() {
      // Create a subtle notification that doesn't interrupt the user
      const notification = document.createElement("div");
      notification.style.cssText = `
        position: fixed;
        top: 70px;
        right: 20px;
        background: linear-gradient(135deg, #28a745, #20c997);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        z-index: 9998;
        box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        animation: slideInRight 0.3s ease-out;
        opacity: 0.9;
      `;
      notification.textContent = "📊 Data updated in real-time";
      
      document.body.appendChild(notification);
      
      // Auto remove after 2 seconds
      setTimeout(() => {
        notification.style.animation = "slideOutRight 0.3s ease-in";
        setTimeout(() => notification.remove(), 300);
      }, 2000);
    }

    // Add modern toast notification system
    function showToast(message, type = "info", duration = 4000) {
      // Remove existing toast if any
      const existingToast = document.getElementById("toast");
      if (existingToast) {
        existingToast.remove();
      }

      // Create toast element
      const toast = document.createElement("div");
      toast.id = "toast";
      toast.textContent = message;

      // Base styles
      const baseStyles = {
        position: "fixed",
        top: "20px",
        right: "20px",
        padding: "12px 20px",
        borderRadius: "8px",
        color: "white",
        fontWeight: "500",
        fontSize: "14px",
        zIndex: "9999",
        boxShadow: "0 4px 12px rgba(0,0,0,0.15)",
        maxWidth: "350px",
        wordWrap: "break-word",
        animation: "slideInRight 0.3s ease-out",
        fontFamily: "Arial, sans-serif",
      };

      // Type-specific styles
      const typeStyles = {
        loading: {
          backgroundColor: "#17a2b8",
          borderLeft: "4px solid #138496",
        },
        success: {
          backgroundColor: "#28a745",
          borderLeft: "4px solid #1e7e34",
        },
        error: {
          backgroundColor: "#dc3545",
          borderLeft: "4px solid #c82333",
        },
        info: {
          backgroundColor: "#007bff",
          borderLeft: "4px solid #0056b3",
        },
      };

      // Apply styles
      Object.assign(
        toast.style,
        baseStyles,
        typeStyles[type] || typeStyles.info
      );

      // Add loading spinner for loading type
      if (type === "loading") {
        const spinner = document.createElement("span");
        spinner.innerHTML = "⏳ ";
        spinner.style.marginRight = "8px";
        toast.insertBefore(spinner, toast.firstChild);
      }

      // Add to document
      document.body.appendChild(toast);

      // Auto remove (except for loading type)
      if (type !== "loading") {
        setTimeout(() => {
          if (toast.parentNode) {
            toast.style.animation = "slideOutRight 0.3s ease-in";
            setTimeout(() => toast.remove(), 300);
          }
        }, duration);
      }

      return toast;
    }

    // Helper function to hide loading toast
    function hideLoadingToast() {
      const toast = document.getElementById("toast");
      if (toast) {
        toast.style.animation = "slideOutRight 0.3s ease-in";
        setTimeout(() => toast.remove(), 300);
      }
    }

    // Add these functions to your existing script

    // Function to update Game ID display
    function updateGameIdDisplay() {
      const gameId = localStorage.getItem("gameId");
      const gamePin = localStorage.getItem("gamePin");
      const display = document.getElementById("gameIdDisplay");
      const qrContainer = document.getElementById("qrCodeContainer");
      const gameIdPinText = document.getElementById("gameIdPinText");
      // For copy function compatibility, keep a hidden input
      let input = document.getElementById("gameIdInput");
      if (!input) {
        input = document.createElement("input");
        input.type = "text";
        input.id = "gameIdInput";
        input.readOnly = true;
        input.style.display = "none";
        if (qrContainer && qrContainer.parentNode) {
          qrContainer.parentNode.appendChild(input);
        }
      }
      if (gameId) {
        // Set value for copy function
        input.value = gameId;
        display.style.display = "block";
        // Render QR code
        if (qrContainer) {
          qrContainer.innerHTML = "";
          new QRCode(qrContainer, {
            text: gameId,
            width: 90,
            height: 90,
            colorDark: "#1565c0",
            colorLight: "#ffffff",
            correctLevel: QRCode.CorrectLevel.H,
          });
        }
        if (gameIdPinText) {
          gameIdPinText.textContent = `ID: ${gameId}   |   PIN: ${gamePin || ''}`;
        }
      } else {
        display.style.display = "none";
        if (qrContainer) qrContainer.innerHTML = "";
        if (gameIdPinText) gameIdPinText.textContent = "";
        input.value = "";
      }
    }

    // Function to copy Game ID with toast feedback
    function copyGameId() {
      const gameIdInput = document.getElementById("gameIdInput");
      const qrContainer = document.getElementById("qrCodeContainer");
      const gameId = gameIdInput.value;

      if (!gameId) {
        showToast("❌ No Game ID to copy!", "error");
        return;
      }

      // Copy to clipboard
      navigator.clipboard
        .writeText(gameId)
        .then(() => {
          // Show success toast
          showToast(`✅ Game ID copied: ${gameId}`, "success", 3000);
          
          // Visual feedback on QR container
          qrContainer.classList.add("copied");
          setTimeout(() => {
            qrContainer.classList.remove("copied");
          }, 1000);
        })
        .catch(() => {
          // Fallback for older browsers
          gameIdInput.select();
          document.execCommand("copy");

          // Show success toast
          showToast(`✅ Game ID copied: ${gameId}`, "success", 3000);
          
          // Visual feedback on QR container
          qrContainer.classList.add("copied");
          setTimeout(() => {
            qrContainer.classList.remove("copied");
          }, 1000);
        });
    }

    // Make Game ID input clickable for selection
    document.addEventListener("DOMContentLoaded", function () {
      const gameIdInput = document.getElementById("gameIdInput");
      if (gameIdInput) {
        gameIdInput.addEventListener("click", function () {
          this.select();
        });
      }

      // Handle scan mode radio button changes
      const modeRadios = document.querySelectorAll('input[name="scanMode"]');
      const pinContainer = document.getElementById("pinContainer");
      const pinInput = document.getElementById("pinInput");
      const pinMessage = document.getElementById("pinMessage");

      modeRadios.forEach(radio => {
        radio.addEventListener("change", function() {
          if (this.value === "edit") {
            // Show PIN container for edit mode
            pinContainer.style.display = "block";
            pinMessage.textContent = "";
            pinMessage.style.color = "#856404";
            pinInput.value = "";
            pinInput.focus();
          } else {
            // Hide PIN container for view mode
            pinContainer.style.display = "none";
            pinMessage.textContent = "👁️ View Only Mode - No PIN required";
            pinMessage.style.color = "#28a745";
          }
        });
      });

      // Handle PIN input for real-time validation
      if (pinInput) {
        pinInput.addEventListener("input", function() {
          // Only allow numeric input
          this.value = this.value.replace(/[^0-9]/g, '');
          
          // Clear any previous message
          pinMessage.textContent = "";
          pinMessage.style.color = "#856404";
          
          // If PIN is complete (4 digits), validate it
          if (this.value.length === 4) {
            setTimeout(() => validatePIN(this.value), 300); // Small delay for better UX
          }
        });

        // Handle Enter key on PIN input
        pinInput.addEventListener("keypress", function(e) {
          if (e.key === "Enter" && this.value.length === 4) {
            validatePIN(this.value);
          }
        });
      }

      // Close QR scanner modal when clicking outside
      const qrModal = document.getElementById("qrScannerModal");
      if (qrModal) {
        qrModal.addEventListener("click", function (event) {
          if (event.target === qrModal) {
            closeQRScanner();
          }
        });
      }

      // Close QR scanner on Escape key
      document.addEventListener("keydown", function (event) {
        if (event.key === "Escape" && qrModal.style.display === "block") {
          closeQRScanner();
        }
      });
    });
    window.onload = function () {
      // Load data first (this generates the tables)
      loadData();
      updateGameIdDisplay();
      
      // Set initial state of WhatsApp buttons after a short delay
      // to ensure the DOM is fully updated with tables
      setTimeout(updateWhatsAppButtons, 100);
      
      // Double-check that real-time listener is running if in view-only mode
      setTimeout(() => {
        if (isViewOnlyMode) {
          const gameId = localStorage.getItem("gameId");
          if (gameId) {
            console.log("Double-checking real-time listener setup on page load");
            startRealtimeListener(gameId);
          }
        }
      }, 1000); // Wait 1 second to ensure Firebase is fully initialized
      
      // Setup mutation observer to detect DOM changes and update WhatsApp buttons
      // This helps with mobile browsers that might have different rendering behavior
      const observer = new MutationObserver((mutations) => {
        // If there are changes to scoreTableContainer or leaderboard, update buttons
        for (let mutation of mutations) {
          if (mutation.type === 'childList' && 
              (mutation.target.id === 'scoreTableContainer' || 
               mutation.target.id === 'leaderboard')) {
            updateWhatsAppButtons();
            break;
          }
        }
      });
      
      // Observe both containers for changes to their children
      observer.observe(document.getElementById('scoreTableContainer'), { childList: true });
      observer.observe(document.getElementById('leaderboard'), { childList: true });
      
      // Start checking for app updates
      startUpdateChecker();
    };

    // Add close game function that clears everything
    async function closeGame() {
      // First, save any unsaved data to cloud before clearing
      await saveCurrentDataToCloud();

      // Clear ALL localStorage data
      localStorage.removeItem("scoreData");
      localStorage.removeItem("gameId");
      localStorage.removeItem("gamePin");
      localStorage.removeItem("gameMode"); // Clear stored mode
      localStorage.clear(); // Remove any other related data

      // Reset view-only mode
      isViewOnlyMode = false;
      removeViewOnlyIndicator();

      // Stop real-time listener
      stopRealtimeListener();

      // Clear the game display
      document.getElementById("scoreTableContainer").innerHTML = "";
      document.getElementById("leaderboard").innerHTML = "";

      // Clear chart
      const canvas = document.getElementById("scoreChart");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (chart) {
        chart.destroy();
        chart = null;
      }

      // Reset inputs to defaults
      document.getElementById("pointValue").value = "1.00";
      document.getElementById("gstPercent").value = "18.00";

      // Hide Game ID display
      const gameIdDisplay = document.getElementById("gameIdDisplay");
      if (gameIdDisplay) {
        gameIdDisplay.style.display = "none";
      }

      // Clear Game ID input
      const gameIdInput = document.getElementById("gameIdInput");
      if (gameIdInput) {
        gameIdInput.value = "";
      }

      // Re-enable game settings
      enableGameSettings();

      // Reset page title
      document.title = "⭐ Rummy Score Master";

      // Hide WhatsApp buttons
      updateWhatsAppButtons();

      // No modal needed - user can see the fresh state immediately
    }

    async function saveCurrentDataToCloud() {
      // Prevent saving in view-only mode
      if (isViewOnlyMode) {
        console.log("Cloud save blocked - View Only Mode");
        return;
      }

      const gameId = localStorage.getItem("gameId");
      const data = localStorage.getItem("scoreData");

      // Only save if we have both gameId and data, and Firebase is ready
      if (!gameId || !data || !window.db) {
        return; // Skip cloud save if no data or Firebase not ready
      }

      try {
        // Parse existing data
        const gameData = JSON.parse(data);

        // Save data to gameData collection only
        const gameDataRef = window.firestore.doc(window.db, "gameData", gameId);
        
        await window.firestore.setDoc(gameDataRef, {
          data: gameData,
          lastUpdated: window.firestore.serverTimestamp(),
          version: "1.0",
        });

        console.log("Data saved to gameData collection for gameId:", gameId);
      } catch (error) {
        console.error("Failed to save to cloud:", error);
        // Don't show error to user, just log it
      }
    }

    // Update confirmCloseGame message
    function confirmCloseGame() {
      showModal(
        "🗑️ Clear Local Game Data",
        "This will permanently delete all game data from your browser's local storage and reset the app. Any data saved to the cloud will remain safe. Continue?",
        () => {
          closeGame();
        }
      );
    }

    // WhatsApp Integration Functions
    
    // Function to show/hide WhatsApp section based on game state
    function updateWhatsAppButtons() {
      // Get all WhatsApp sharing buttons by their onclick attribute
      const whatsAppButtons = document.querySelectorAll('button[onclick^="post"][onclick$="WhatsApp()"]');
      const gameData = localStorage.getItem("scoreData");
      
      // Show or hide WhatsApp buttons based on whether a game is active
      whatsAppButtons.forEach(button => {
        if (gameData) {
          button.style.display = "flex";
          console.log("WhatsApp button display set to flex");
        } else {
          button.style.display = "none";
          console.log("WhatsApp button display set to none");
        }
      });
      
      // If no buttons were found but game data exists, we might need to wait for the DOM
      // This can happen on page refresh when elements aren't fully rendered yet
      if (whatsAppButtons.length === 0 && gameData) {
        console.log("No WhatsApp buttons found but game data exists. Setting timeout to retry.");
        setTimeout(updateWhatsAppButtons, 500); // Try again in 500ms
      }
    }

    // Function to get last completed round results
    function getLastCompletedRoundResults() {
      const numPlayers = document.querySelectorAll('input[id^="name"]').length;
      let lastCompletedRound = 0;
      
      // Find the last completed round
      for (let round = 1; round <= 10; round++) {
        let completedPlayers = 0;
        
        // Check if all players have entered scores for this round
        for (let player = 1; player <= numPlayers; player++) {
          const scoreInput = document.getElementById(`p${player}r${round}`);
          // Check if score is entered (including 0) but not -1 (not played)
          if (scoreInput && scoreInput.value !== '' && scoreInput.value !== '-1') {
            completedPlayers++;
          }
        }
        
        // If all players completed this round, update lastCompletedRound
        if (completedPlayers === numPlayers) {
          lastCompletedRound = round;
        } else {
          // If this round is not completed, stop searching
          break;
        }
      }
      
      const roundResults = [];
      
      // If no rounds are completed yet, return empty results
      if (lastCompletedRound === 0) {
        return {
          roundNumber: 0,
          currentRound: 'NO ROUNDS COMPLETED',
          results: []
        };
      }
      
      for (let i = 1; i <= numPlayers; i++) {
        const nameInput = document.getElementById(`name${i}`);
        const scoreInput = document.getElementById(`p${i}r${lastCompletedRound}`);
        
        if (nameInput && scoreInput) {
          const name = nameInput.value.trim() || `Player ${i}`;
          const score = scoreInput.value;
          const randomNumber = nameInput.dataset.randomNumber;
          
          roundResults.push({
            name: name,
            score: score,
            randomNumber: randomNumber
          });
        }
      }
      
      return {
        roundNumber: lastCompletedRound,
        currentRound: `R${lastCompletedRound}`,
        results: roundResults
      };
    }

    // Function to format round results for WhatsApp
    function formatRoundResultsForWhatsApp() {
      const roundData = getLastCompletedRoundResults();
      const gameId = localStorage.getItem("gameId");
      const pointValue = parseFloat(document.getElementById("pointValue").value) || 0.15;
      
      // Check if no rounds are completed yet
      if (roundData.roundNumber === 0) {
        return "No rounds completed yet. Complete a round to share results!";
      }
      
      let message = `🎯 *ROUND ${roundData.roundNumber} RESULTS* 🎯\n\n`;
      message += `Game ID: ${gameId}\n`;
      message += `Point Value: ₹${pointValue}\n\n`;
      
      // Sort results by score (lowest first for Rummy)
      const sortedResults = roundData.results.sort((a, b) => {
        // Handle 0 scores properly in comparison
        const scoreA = a.score === "0" ? 0 : parseInt(a.score) || -1;
        const scoreB = b.score === "0" ? 0 : parseInt(b.score) || -1;
        return scoreA - scoreB;
      });
      
      sortedResults.forEach((player, index) => {
        // Parse score, being careful to distinguish between 0 and -1
        const score = player.score === "0" ? 0 : parseInt(player.score) || -1;
        // Display "Not played" only for -1 scores; 0 is displayed as "0"
        const scoreText = score === -1 ? "Not played" : score.toString();
        const playerName = player.randomNumber ? `${player.name} (#${player.randomNumber})` : player.name;
        
        // Add emoji based on position
        let emoji = "";
        if (index === 0 && score !== -1) emoji = "🥇";
        else if (index === 1 && score !== -1) emoji = "🥈";
        else if (index === 2 && score !== -1) emoji = "🥉";
        else if (score === -1) emoji = "⏳";
        else emoji = "📊";
        
        message += `${emoji} ${playerName}: ${scoreText}\n`;
      });
      
      message += `\n${roundData.currentRound === 'GAME OVER' ? '🏁 GAME COMPLETED! 🏁' : '🎮 Keep playing!'}`;
      
      return message;
    }

    // Function to format leaderboard for WhatsApp
    function formatLeaderboardForWhatsApp() {
      const gameId = localStorage.getItem("gameId");
      const pointValue = parseFloat(document.getElementById("pointValue").value) || 0.15;
      const gstPercent = parseFloat(document.getElementById("gstPercent").value) || 25.0;
      const numPlayers = document.querySelectorAll('input[id^="name"]').length;
      
      // Get current scores
      const scores = [];
      for (let i = 1; i <= numPlayers; i++) {
        let total = 0;
        for (let j = 1; j <= 10; j++) {
          const scoreInput = document.getElementById(`p${i}r${j}`);
          if (scoreInput) {
            const val = parseInt(scoreInput.value);
            total += isNaN(val) || val === -1 ? 0 : val;
          }
        }
        const nameInput = document.getElementById(`name${i}`);
        const name = nameInput ? nameInput.value.trim() : `Player ${i}`;
        const randomNumber = nameInput ? nameInput.dataset.randomNumber : null;
        scores.push({ name, total, randomNumber });
      }
      
      // Sort by total score (lowest wins)
      const sortedScores = [...scores].sort((a, b) => a.total - b.total);
      
      // Calculate settlement amounts
      const totalAllScores = sortedScores.reduce((sum, score) => sum + score.total, 0);
      sortedScores.forEach((score) => {
        score.grossAmount = Math.round((totalAllScores - score.total * numPlayers) * pointValue);
        if (score.grossAmount > 0) {
          score.gstPaid = Math.round((score.grossAmount * gstPercent) / 100);
          score.netAmount = score.grossAmount - score.gstPaid;
        } else {
          score.gstPaid = 0;
          score.netAmount = score.grossAmount;
        }
      });
      
      let message = `🏆 *FINAL LEADERBOARD* 🏆\n\n`;
      message += `Game ID: ${gameId}\n`;
      message += `Point Value: ₹${pointValue}\n`;
      message += `GST: ${gstPercent}%\n\n`;
      
      sortedScores.forEach((score, index) => {
        const playerName = score.randomNumber ? `${score.name} (#${score.randomNumber})` : score.name;
        
        // Add medal emoji
        let emoji = "";
        if (index === 0) emoji = "🥇";
        else if (index === 1) emoji = "🥈";
        else if (index === 2) emoji = "🥉";
        else emoji = `${index + 1}.`;
        
        const amountText = score.netAmount > 0 ? `+₹${score.netAmount}` : `₹${score.netAmount}`;
        const amountColor = score.netAmount > 0 ? "🟢" : score.netAmount < 0 ? "🔴" : "⚪";
        
        message += `${emoji} ${playerName}\n`;
        message += `   Score: ${score.total}\n`;
        message += `   ${amountColor} ${amountText}\n\n`;
      });
      
      // Calculate total GST collected
      const totalGstCollected = sortedScores.reduce((sum, score) => sum + score.gstPaid, 0);
      message += `💰 Total GST Collected: ₹${totalGstCollected}\n\n`;
      message += `🎉 Thanks for playing! 🎉`;
      
      return message;
    }

    // Function to post round results to WhatsApp GST group
    function postRoundResultsToWhatsApp() {
      const message = formatRoundResultsForWhatsApp();
      
      // Check if no rounds are completed yet
      if (message === "No rounds completed yet. Complete a round to share results!") {
        showToast("⚠️ No rounds completed yet. Complete a round to share results!", "warning", 3000);
        return;
      }
      
      const encodedMessage = encodeURIComponent(message);
      
      // Use standard WhatsApp sharing (user will select the group)
      const whatsappUrl = `https://wa.me/?text=${encodedMessage}`;
      
      // Open WhatsApp in new tab
      window.open(whatsappUrl, '_blank');
      
      // Show success toast with instructions
      showToast("📱 Opening WhatsApp with last completed round results. Select your GST group and click 'Send'!", "success", 4000);
    }

    // Function to post leaderboard to WhatsApp GST group
    function postLeaderboardToWhatsApp() {
      const message = formatLeaderboardForWhatsApp();
      const encodedMessage = encodeURIComponent(message);
      
      // Use standard WhatsApp sharing (user will select the group)
      const whatsappUrl = `https://wa.me/?text=${encodedMessage}`;
      
      // Open WhatsApp in new tab
      window.open(whatsappUrl, '_blank');
      
      // Show success toast with instructions
      showToast("📱 Opening WhatsApp with leaderboard. Select your GST group and click 'Send'!", "success", 4000);
    }
  </script>
</body>
</html>